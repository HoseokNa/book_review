# CHAPTER 1 스코프란 무엇인가

* [1-1 컴파일러 이론](#1-1-컴파일러-이론)
* [1-2 스코프 이해하기](#1-2-스코프-이해하기)
* [1-3 중첩 스코프](#1-3-중첩-스코프)
* [1-4 오류](#1-4 오류)

변수를 프로그램에 추가하면 다음과 같은 질문이 생긴다.

* 변수는 어디에 살아 있는가? 다른 말로 하면 변수는 어디에 저장되는가?
* 필요할 때 프로그램은 어떻게 변수를 찾는가?

특정 장소에 변수를 저장하고 나중에 그 변수를 찾는 데는 잘 정의된 규칙이 필요하다. 바로 이런 규칙을 '스코프'라 한다.

## 1-1 컴파일러 이론

자바스크립트는 사실 '컴파일러 언어' 다. 물론 자바스크립트가 코드를 미리 컴파일하거나 컴파일한 결과를 분산 시스템에서 이용할 수 있는 것은 아니다. 하지만 자바스크립트 엔진은 전통적인 컴파일러 언어에서 컴파일러가 하는 일의 상당 부분을 우리가 아는 것보다 세련된 방식으로 처리한다.

전통적인 컴파일러 언어의 처리 과정에는 프로그램을 이루는 소스 코드가 실행되기 전에 보통 3단계를 걸치는데, 이를 '컴파일레이션(Compilation')이라고 한다.

### Tokenizing/Lexing

문자열을 나누어 '토큰(Token)'이라 불리는 의미 있는 조각으로 만드는 과정이다. 예를 들어 "var a =2;" 는 var, a, =, 2, ; 로 나누어진다. 빈칸은 하나의 토큰으로 남을 수도 있고 아닐 수도 있다. 이는 빈칸이 의미가 있느냐, 없느냐에 달렸다.

NOTE: 토크나이저가 상태 유지 파싱 규칙을 적용해 a가 별개의 토큰인지 다른 토큰의 일부인지를 파악한다면 렉싱이다. (토큰을 인식할 때 무상태 방식으로 하는지 상태 유지 방식으로 하는지에 따라 토크나이징 렉싱 구분)

### Parsing

토큰 배열을 프로그램의 문법 구조를 반영하여 중첩 원소를 갖는 트리 형태로 바꾸는 과정이다. 파싱의 결과로 만들어진 트리를 AST(추상 구문 트리)라 부른다.

"var a =2;"의 트리는 먼저 Variable Declaration 이라 부르는 최상위 노드에서 시작한다. 최상위 노드는 'a'의 값을 가지는 Identifier와 Assignment Exprsesion 이라 부르는 자식 노드를 가진다. Assignment Expression은 '2' 라는 값을 가지는 Numeric Literal을 자식 노드로 가진다.

### Code Generation

AST를 컴퓨터에서 실행 코드로 바꾸는 과정이다. 이 부분은 언어에 따라 목표하는 플랫폼에 따라 크게 달라진다. 세부사항을 알기보다는 "var a = 2;"를 나타내는 AST를 기계어 집합으로 바꾸어 실제로 'a'라는 변수를 생성하고 값을 저장할 방법 있다고 생각하자.

자바스크립트 엔진은 파싱과 코드 생성 과정에서 불필요한 요소를 삭제하는 과정을 거쳐 실행 시 성능을 최적화한다.

자바스크립트 엔진이 기존 컴파일러와 다른 점은 자바스크립트 컴파일레이션을 미리 수행하지 않아서 최적화할 시간이 많지 않다는 것이다.

자바스크립트 컴파일레이션은 보통 코드가 실행되기 겨우 수백만 분의 일초 전에 수행한다. 즉, 어떤 자바스크립트 조각이라도 실행되려면 먼저(보통 바로 직전에!) 컴파일되어야 한다는 것이다.

## 1-2 스코프 이해하기

스코프를 좀 더 재미있고 쉽게 설명하기 위해 대화 형식으로 스코프를 살펴보겠다.

### 1-2-1 출연진

"var a = 2;"를 처리할 주역들이다.

* 엔진 : 컴파일레이션의 시작부터 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임진다.
* 컴파일러 : 엔진의 친구로, 파싱과 코드 생성의 모든 잡일을 도맡아 한다.
* 스코프 : 엔진의 또 다른 친구로, 선언된 모든 확인자(변수) 검색 목록을 작성하고 유지한다. 또한, 엄격한 규칙을 강제하여 현재 실행 코드에서 확인자의 적용 방식을 정한다.

### 1-2-2 앞과 뒤

프로그램 "var a= 2;"를 보면 하나의 구문으로 보인다.

엔진은 두 개의 서로 다른 구문으로 본다. 하나는 컴파일러가 컴파일레이션 과정에서 처리할 구문이고, 다른 하나는 실행 과정에서 엔진이 처리할 구문이다.

이 프로그램에서 컴파일러가 할 첫 번째 일은 렉싱을 통해 구문을 토큰으로 쪼개는 것이다. 그 후 토큰을 파싱해 트리 구조로 만든다. 그러나 코드 생성 과정에 들어가면 컴파일러는 몇몇 독자의 추측과는 다르게 프로그램을 처리한다.

컴파일러가 다음 의사 코드로 요약될 수 있는 코드를 생성한다고 생각할 수 있다.

```
변수를 위해 메모리를 할당하고 할당된 메모리를 a라 명명한 후 그 변수에 값 2 를 넣는다.
```

정확한 설명이 아니다. 컴파일러는 다음 일을 진행한다.

1. 컴파일러가 'var a'를 만나면 스코프에게 변수 a가 특정한 스코프 컬렉션 안에 있는지 묻는다. 변수 a가 이미 있다면 컴파일러는 선언을 무시하고 지나가고, 그렇지 않으면 컴파일러는 새로운 변수 a를 스코프 컬렉션 내에 선언하라고 요청한다.
2. 그 후 컴파일러는 'a = 2' 대입문을 처리하기 위해 나중에 엔진이 실행할 수 있는 코드를 생성한다. 엔진이 실행하는 코드는 먼저 스코프에게 a라 부르는 변수가 현재 스코프 컬렉션 내에서 접근할 수 있는지 확인한다. 가능하다면 엔진은 변수 a를 사용하고, 아니라면 엔진은 다른 곳(중첩 스코프 부분을 보라)을 살핀다.

엔진이 마침내 변수를 찾으면 변수에 값 2를 넣고, 못 찾는다면 엔진은 에러가 발생했다고 알린다.

요약하면 첫째, 컴파일러가 변수를 선언한다.(현재 스코프에 미리 변수가 선언되지 않은 경우) 둘째, 엔진이 스코프에서 변수를 찾고 변수가 이싿면 값을 대입한다.

### 1-2-3 Compiler Speak

컴파일러가 생성한 코드를 실행할 때 엔진은 변수 a가 선언된 적이 있는지 스코프에서 검색한다. 이 때 엔진이 LHS검색을 하느냐 RHS 검색을 하느냐에 다라 검색 결과가 달라진다.

LHS 검색은 변수가 대입 연산자의 왼쪽에 있을 때 수행하고, RHS 검색은 변수가 대입 연산자의 오른쪽에 있을 때 수행한다.

좀 더 엄밀하게 말하면 RHS는 '왼편이 아닌 쪽', '가서 값을 가져오라' 라는 뜻으로 이해할 수 있다.

```js
console.log(a);
```

a 에 대한 참조는 RHS 참조다. 구문에서 a에 아무것도 대입하지 않기 때문이다. 대신 a의 값을 가져와 console.log()에 넘겨준다.

```js
a = 2;
```

a에 대한 참조는 LHS 참조다. 현재 a 값을 신경 쓸 필요 없이 '= 2' 대입 연산을 수행할 대상 변수를 찾기 때문이다

NOTE: 대입 연산은 여러 방식으로 일어날 수 있기 때문에 대입할 대상(LHS), 대입할 값(RHS)이라고 생각하는 것이 더 낫다.

LHS와 RHS 참조를 모두 수행하는 다음 프로그램을 보자.

```js
function foo( a ) {
  console.log( a ); // 2
}
foo( 2 );
```

마지막 줄 foo() 함수를 호출하는데 RHS 참조를 사용한다. 즉 "가서 foo의 값을 찾아 내게 가져와라" 라는 뜻이다. 여기서 ()는 실행된다는 뜻이므로 foo는 함수여야 한다.

이 부분에서 미묘하지만 중요한 대입이 수행된다.

인수로 값 2를 함수 foo()에 넘겨 줄 때 값 2를 인자 a에 대입하는 연산이 일어난다. 이 (내재된) 인자 a에 대한 대입 연산을 위해 LHS 검색이 수행된다.

변수 a에 대한 RHS 참조 역시 수행되는데, 그 결괏값은 console.log() 함수에 넘겨진다. 또 console.log()가 실행되려면 참조가 필요하다. console 객체를 RHS 검색하여 log 메서드가 있는지 확인한다.

구현된 log()의 내부에는 인자가 있을 것이고, 첫 번째 인자(어쩌면 arg1이라 부를 것)를 LHS 검색으로 찾아 2를 대입할 것이다.

NOTE: 함수 선언문 "function foo(a) { }"를 "var foo"와 "foo = function(a) {}" 같은 일반적인 변수 선언 및 대입과 같다고 생각할 수 있다. 하지만 컴파일러는 앞의 선언문과 값 정의문을 코드 생성 과정에서 처리하여 엔진이 코드를 실행할 때는 foo에 함수값을 대입하는 과정이 필요 없다. 따라서 함수 선언을 앞에서 살펴본 변수의 경우와 같이 LHS 검색 및 대입 과정이라고 생각하는 것은 적절하지 않다.

### 1-2-4 엔진과 스코프의 대화

```js
function foo(a) {
  console.log(a); // 2
}

foo(2);
```

이 코드의 실행 과정을 대화로 상상해 보자.

```
엔진 : 안녕, 스코프. foo에 대한 RHS 참조가 필요해. foo 들어봄?

스코프 : 응. 들어봄. 컴파일러가 좀 전에 선언함. foo는 함수임. 보셈

엔진 : 고마워. 이제 foo를 실행할게.

엔진 : 스코프. a에 대한 LHS 참조도 필요함. 들어봄?

스코프 : ㅇㅇ, 컴파일러가 a를 foo의 인자로 좀 전에 선언함. 보셈

엔진 : ㅇㅋ. 이제 2를 a에 대입해야함.

엔진 : 님, console에 대한 RHS 검색이 필요함. ㅈㅅ..

스코프 : ㄱㅊ, console 찾음. 내장됐음.

엔진 : 굳. log()를 찾아볼까. 함수넹

엔진 : 님님, a의 RHS 참조 찾아주셈. 나한테도 있지만 확실히 하려고.

스코프 : 올ㅋ. 여기 있음

엔진 : a의 값은 2구나. log()에 넘길게
```


## 1-3 중첩 스코프

스코프는 확인자 이름으로 변수를 찾기 위한 규칙의 집합이라고 앞서 말했다. 그러나 대개 고려해야 할 스코프는 여러 개다.

스코프도 다른 스코프 안에 중첩 될 수 있다. 따라서 대상 변수를 현재 스코프에서 발견하지 못하면 엔진은 다음 바깥의 스코프로 넘어가는 식으로 변수를 찾거나 글로벌 스코프라 부르는 가장 바깥 스코프에 도달할 때까지 계속한다.

```js
function foo(a) {
  console.log( a + b);
}

var b = 2;

foo( 2 ); // 4
```

b에 대한 RHS 참조는 함수 foo 안에서 처리할 수 없고, 함수를 포함하는 스코프(이 경우에는 글로벌 스코프)에서 처리한다.

엔진과 스코프의 대화를 다시 보자.

```
엔진 : foo의 스코프 b 뭐임? b에 대한 RHS 참조가 필요함.

스코프(foo) : ㄴㄴ, 모름.

엔진 : 바깥 스코프! 아 글로벌 스코프네. 혹시 b 있음?

스코프(글로벌) : ㅇㅇ. 여기 있음.
```

중첩 스코프를 탐사할 때 사용하는 간단한 규칙은 다음과 같다.

* 엔진은 현재 스코프에서 변수를 찾기 시작하고, 찾지 못하면 한 단계씩 올라간다.
* 최상위 글로벌 스코프에 도달하면 변수를 찾았든, 못 찾았든 검색을 멈춘다.

## 1-4 오류

LHS와 RHS를 구분하는 것이 왜 중요할까? 이 두 종류의 검색 방식은 변수가 아직 선언되지 않았을 때(검색한 모든 스코프에서 찾지 못했을 때) 서로 다르게 동작하기 때문이다.

```js
function foo(a) {
  console.log( a + b);
  b = a;
}

foo( 2 );
```

b에 대한 첫 RHS 검색이 실패하면 다시는 b를 찾을 수 없다. 이렇게 스코프에서 찾지 못하느 변수는 '선언되지 않는 변수'라 한다. RHS 검색이 중첩 스코프 안 어디에서도 변수를 찾지 못하면 엔진이 'ReferenceError'를 발생시킨다.

반면에, 엔진이 LHS 검색을 수행하여 변수를 찾지 못하고 최상위 층(글로벌 스코프)에 도착할 때 프로그램이 'Strict Mode'로 동작하고 있는 것이 아니라면, 글로벌 스코프는 엔진이 검색하느 ㄴ이름을 가진 새로운 변수를 생성해서 엔진에게 넘겨준다.

이제 RHS 검색 결과 변수를 찾았지만 그 값을 가지고 불가능한 일을 하려고 할 경우를 보자. 예를 들어, 함수가 아닌 값을 함수처럼 실행하거나 null이나 undefined 값을 참조할 때 엔진은 TypeError를 발생시킨다.

ReferenceError는 스코프에서 대상을 찾았는지와 관계있지만, TypeError는 스코프 검색은 성공했으나 결괏값을 가지고 적합하지 않거나 불가능한 시도를 한 경우를 의미한다.

## 1-5 정리하기

스코프는 어디서 어떻게 변수(확인자)를 찾는가를 결정하는 규칙의 집합이다. 변수를 검색하는 이유는 변수에 값을 대입하거나(LHS 참조) 변수의 값을 얻어오기 위해서다(RHS 참조).

LHS 참조는 대입 연산 과정에서 일어난다. 스코프와 관련된 대입 연산은 '=' 연산자가 사용되거나 인자를 함수의 인자로 넘겨줄 때 일어난다.

자바스크립트 엔진은 코드를 실행하기 전에 먼저 컴파일하는데, 이 과정에서 엔진은 "var a = 2;"와 같은 구문을 독립된 두 단계로 나눈다.

1. var a는 변수 a를 해당 스코프에 선언한다. 이 단계는 코드 실행 전에 처음부터 수행된다.
2. a = 2는 변수 a를 찾아 값을 대입한다(LHS 참조).

LHS, RHS 참조 검색은 모두 현재 실행 중인 스코프에서 시작한다. 그리고 필요하다면(대상 변수를 찾지 못했을 경우) 한 번에 한 스코프씩 중첩 스코프의 상위 스코프로 넘어가며 확인자를 찾는다. 이 작업은 글로벌 스코프(최상위 층)에 이를 때까지 계속하고 대상을 찾았든, 못 찾았든 작업을 중단한다.

RHS 참조가 대상을 찾지 못하면 ReferenceError가 발생한다. LHS 참조가 대상을 찾지 못하면 자동적, 암시적으로 글로벌 스코프에 같은 이름의 새로운 변수가 생성된다.(만약 'Strict Mode'일 경우 ReferenceError가 발생함)
