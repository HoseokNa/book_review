# CHAPTER 5 문법

마지막으로 자바스크립트 언어에서 구문이 어떻게 작동하는지(문법) 알아보자.

자바스크립트 문법은 각종 구문(연산자, 키워드)들을 서로 잘  끼워 맞춰 규칙에 맞는, 유효한 프로그램을 만들기 위한, 구조적 방법이다. 개발자들이 직접 마주할 대상은 있는 그대로의 언어 구문이지만 이 장에서는 최대한 정확한 문법을 기술하는데 초첨을 둘 것이다. 

* [5-1 문과 표현식](#5-1-문과-표현식)

## 5-1 문과 표현식

자바스크립트에서 문(Statement)과 표현식(Expression)은 아주 주용한 차이가 있으므로 명확하게 분별하자.

영어에 대입해보면 문(Statement)은 문장(Sentence), 표현식(Expression)은 어구(Phrase), 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다.

```js
var a = 3 * 6;
var b = a;
b;
```

3가지 모두 표현식. 그리고 표현식이 포함된 문.

var a= 3 * 6, var b = a 두 문은 각각 변수를 선언(그리고 어떤 값으로 할당)하므로 '선언문'이라 한다.
(앞에 var가 빠진) a = 3 * 6, b = a 는 '할당 표현식'이라고 한다.

세 번째 줄 b 는 '표현식 문'이라고 일컫는다.

### 5-1-1 문의 완료 값

모든 문은 (값이 undefined라 해도) 완료 값(Completion Value)을 가진다는 사실을 의외로 모르는 사람이 많다.

문의 완료 값을 확인하는 방법은 브라우저 개발자 콘솔 창에서 문을 타이핑해보는 것이다. 콘솔 창은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력하게 되어 있다.

var b = a 같은 문은 완료 값이 뭘까?

할당 표현식 b = a는 할당 이후의 값(여기서는 18)이 완료 값이지만, var 문 자체의 완료 값은 udefined다. 명세에 그렇게 적혀있기 때문이다.

완료 값을 순간 포착할 방법은 없을까? 근데 왜 꼭 그래야하는지부터 생각하자.

예를 들어, 보통의 { } 블록은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료 값으로 반환한다.

```js
var b;

if (true) {
	b = 4 + 38;
}
```

b = 4 + 38의 완료값인 42가 반환된다.

즉, 블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.

하지만 다음과 같은 코드가 작동하지 않는 건 문제가 있다.

```js
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

문의 완료 값을 포착하여 다른 변수에 할당한다는 건 쉬운 구문/문법으로는 불가능하다.

*예를 들기 위함이니 아래 코드는 실제로 사용하지 말자*

유해함의 대명사 eval() 함수를 사용할 수 밖에 없다.

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

꼴보기 싫은 코드지만 잘 돌아간다!

ES7 명세에는 'do 표현식'이 제안된 상태다.

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

do { } 표현식은 (하나 이상의 문을 포함한) 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.

아직까지는 문 완료 값을 대수롭지 않게 여기고 있지만 자바스크립트 언어가 진화할수록 그 중요성은 점점 더 부각될 것 같다.

다시 경고하지만 eval()은 사용하지 말자. 자세한 내용은 2부 스코프와 클로져를 참고하자.

### 5-1-2 표현식의 부수 효과

대부분의 표현식에는 부수 효과가 없다.

```js
var a = 2;
var b = a + 3;
```

표현식 a + 3 자체는 가령 a 값을 바꾸는 등의 부수 효과가 전혀 없다. 단지 b = a + 3 문에서 결괏값 5가 b에 할당될 뿐이다.

다음의 함수 호출 표현식은 부수 효과를 가진(가졌을지 모를) 표현식의 전형적인 예다.

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// 결괏값: `undefined`, side effect: `a` 가 변경됨.
```

다른 부수 효과를 지닌 표현식.

```js
var a = 42;
var b = a++;
```

표현식 a++이 하는 일은 두 가지다. a의 현재 값 42를 반환(그리고 b에 할당하는 것까지)하고 a 값을 1만큼 증가시킨다.

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

여기서 b 값을 43으로 착각하는 개발자들이 생각보다 많다. 부수효과가 있다는 걸 잘몰라서

```js
var a = 42;

a++;	// 42
a;		// 43

++a;	// 44
a;		// 44
```

++를 전위 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 부수 효과를 일으킨다. 반면, 후위 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.

NOTE: ++a++ 는 문법에 맞는 구문일까? Reference Error 발생. 부수 효과를 유발하는 연산자는 부수 효과를 일으킬 변수 레퍼런스가 꼭 필요하기 떄문이다. 우선순위 규칙에 의해 a++가 먼저 실행되어 42를 반환한다. ++ 연산자는 42 같은 원시 값에 부수 효과를 일으킬수 없으므로 ReferenceError를 던진다.

a++를 ()로 감싸면 후위 부수 효과를 캡슐화할 수 있다고 착각하는 경우도 더러 있다.

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

() 둘러싼다 해도 a++ 표현식에서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다.

하지만 문을 나열하는 콤마 연산자 , 를 사용하면 다수의 개별 표현식을 하나의 문으로 연결할 수 있다.

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

NOTE: 뒷부분에서 다시 얘기 하겠지만 ( a++ , a ) 에서 괄호를 빠뜨리면 안된다.

두번째 a 표현식을 첫 번째  a++ 표현식에서 부수 효과가 발생한 이후에 평가한다. 그래서 b 값은 43이다.

delete 역시 부수 효과를 일으키는 연산자다. delete는 객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 쓴다. 하지만 단독 문으로 더 많이 쓴다.

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

delete 연산자의 결괏값은 유효한/허용된 연산일 경우 true, 그 외에는 false다. 이 연산자의 부수 효과는 바로 프로퍼티(또는 배열 슬롯)을 제거하는 것이다.

NOTE: '유효한/허용된'의 의미. 존재하지 않는 프로퍼티 또는 존재하면서 설정 가능한 프로퍼티일 경우, delete 연산자는 true를 반환. 그 외의 경우는 false를 반환.(this와 프로토타입, 비동기와 성능 참고)

마지막 예시는 = 할당 연산자.

```js
var a;

a = 42;		// 42
a;			// 42
```

42를 a에 할당하는 자체가 본질적으로 부수 효과다.

이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 다음과 같은 연쇄 할당문에서 특히 유용하다.

```js
var a, b, c;

a = b = c = 42;
```

c = 42 평가 결과는 (42를 c에 할당하는 부수 효과를 일으키며) 42가 되고, b = 42 평가 결과는 (42를 b에 할당하는 부수 효과를 일으키며) 42가 된다. 결국, a = 42로 (42를 a에 할당하는 부수 효과를 일으키며) 평가 된다.

NOTE: var a= b = 42 처럼 연쇄 할당문을 잘못 쓰는 경우가 많다. 변수 b를 선언하지 않은 상태에서 실행하면 이 할당문은 b를 직접 선언하지 않는다. 대신, 엄격 모드 여부에 따라 에러가 나거나 원치 않는 전역 변수가 생성된다.

```js
function vowels(str) {
	var matches;

	if (str) {
		// 모든 모음을 추출한다.
		matches = str.match( /[aeiou]/g );

		if (matches) {
			return matches;
		}
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

잘 동작한다. 많은 개발자가 이렇게 작성한다. 할당 연산자의 부수 효과를 잘 활용하면 다음과 같이 2개의 if 문을 하나로 간단히 합칠 수 있다.

```js
function vowels(str) {
	var matches;

	// 모든 모음을 추출한다.
	if (str && (matches = str.match( /[aeiou]/g ))) {
		return matches;
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

 NOTE: matches = str.match( /[aeiou]/g) 를 감싸는 ( )를 빠뜨리면 안된다.

 두 조건이 서로 분명히 연관되어 있음을 잘 보여주기 때문에 필자는 후자를 더 선호하는 편이다. 물론 취향 차이. 

### 5-1-3 콘텍스트 규칙

같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 하나씩 떨어뜨려 놓고 보면 상당히 헷갈리 수 있다.

자주 나오는 몇 가지 사례를 살펴보자.

#### 중괄호

자바스크립트에서 중괄호 {}가 나올 법한 곳은 크게 두 군데다.

#### 객체 리터럴

첫째, 객체 리터럴이다.

```js
// `bar()` 함수는 앞에 정의되었다.

var a = {
	foo: bar()
};
```

{ }는 a에 할당될 값이므로 객체 리터럴이 맞다.

NOTE: 래퍼런스 a는 할당의 대상이므로 'ㅣ 값 L-Value'(좌측 lefthand 값), { }는 할당의 원본 값이므로 'r 값 R-Value'(우측 Righthand 값)이라고도 한다.

#### 레이블

방금전 코드에서 var a = 부분을 삭제하면 어떻게 될까?

```js
// `bar()` 함수는 앞에 정의도었다.

{
	foo: bar()
}
```

{ }는 어디에도 할당되지 않은, 그저 고립된 객체 리터럴처럼 보인다. 하지만 전혀 그렇지 않다.

여기서의 { }는 평범한 코드 블록이다. 특히 let 블록 스코프 선언과 함께 쓰이면 아주 유용하다. (2부 스코프와 클로저 참고.)

이 { } 코드 블록은 for/while 루프, if 조건 등에 붙어있는 코드 블록과 기능적으로 매우 유사하다.

근데 foo: bar()가 특이하게 보이는데 어떻게 이런 코드가 문법에 부합하나?

그건 자바스크립트에서 '레이블 문(Labled Statement)'이라는 기능 덕분이다.(솔직히 비권장) 즉 foo는 bar() 문의 레이블이다.

자바스크립트는 제한적이기는 해도 레이플 점프라는 특별한 형태의 goto 장치가 대신 마련되어 있다. continue와 break 문은 선택적으로 어떤 레이블을 받아 goto처럼 프로그램의 실행 흐름을 'jump' 시킨다.

```js
// `foo` 레이블 루프
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// 두 루프의 반복자가 같을 때마다 바깥쪽 루프를 continue 한다.
		if (j == i) {
			// 다음 순회 시 'foo' 붙은 루프로 점프한다.
			continue foo;
		}

		// 홀 수 배 수는 건너 뛴다.
		if ((j * i) % 2 == 1) {
			// 평범한 (레이블 없는) 안쪽 루프의 `continue`
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

NOTE: continue foo는 "foo라는 레이블 위치도 이동하여 계속 순회라"는 의미가 아니라 *"foo라는 레이블이 붙은 루프의 다음 순회를 계속하라"*라는 뜻이다. 따라서 사실 임의적인 goto와는 다르다.

아마도 바깥쪽 루프로 나가야 할 지점에 안쪽 푸르에서 break __ 처럼 사용해야 레이블 루프 점프로 좀 더 잘 활용하는 모습이 될 것 같다.

```js
// `foo` 레이블 루프
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "그만!", i, j );
			// `foo` 레이블 루프에서 벗어나다
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// 그만! 1 3
```

break foo는 "foo라는 레이블 위치로 이동하여 계속 순회하라"는 의미가 아니라, "foo라는 레이블이 붙은 바깥쪽 루플/블록 밖으로 나가 그 이후부터 계속하라"는 뜻이다. 역시 전통적인 goto와는 의미가 사뭇 다르다.

방금전 예제를 레이블 없는 break로 작성하려면 코드가 더 복잡해지고 혼란스러워질 수 있다. 따라서 이런 경우라면 레이블 break 사용이 더 나은 선택이라 할 수 있다.

레이블은 비 루프 브록에 적요할 수 있다. 단 이런 비 루프 레이블은 break만 참조 할 수 있다.(continue __, 레이블 없는 break 사용 불가)

```js
function foo() {
	// `bar` 레이블 블록
	bar: {
		console.log( "Hello" );
		break bar;
		console.log( "절대 실행 안됨" );
	}
	console.log( "World" );
}

foo();
// Hello
// World
```

레이블 루프/블록은 사용빈도가 극히 드물고 못마땅한 구석도 많아 가능한 한 피하는게 상책이다. 이를테면 루프 점프를 할 바에야 차라리 함수 호출이 더 낫다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 사용하게 된다면 여러분이 뜻한 바를 상세한 주석으로 잘 문서화 하자.

JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다. (가령 JSON 문자열 {"a":42}를 콘솔 창에 입력하면 에러 발생. 자바스크립트 문의 레이블은 따옴표로 감싸면 안되기 때문)

JSON 문자열로만 가득 채워진 파일을 \<script src=...> 태그로 읽어 들여도 정상적인 자바스크립트 코드로 인식될 거라고 흔히 오해한다. 하지만 이런 파일은 프로그램에서 접근조차 할 수 없다. 그래서 보통 JSON-P(JSON 데이터를 함수 호출로 감싸는 패턴) 방식으로 접근이 안되는 문제를 해결 할 수 있다고 한다.

정확한 해석은 이렇다. {"a":42}는 완전히 올바른 JSON 값이지만, 그 자체로는 레이블이 잘못된 문 블록으로 해석되어 에러가 난다. 하지만 foo({"a":42})는 함수 내부에서 {"a":42}가 foo()에 전달된 객체 리터럴이므로 유효한 자브스크립트 코드다. 따라서 JSON-P가 JSON을 문법에 맞는 자바스크립트 코드로 옷을 갈아입혀 주는 셈이다.
