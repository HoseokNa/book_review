# CHAPTER 5 문법

마지막으로 자바스크립트 언어에서 구문이 어떻게 작동하는지(문법) 알아보자.

자바스크립트 문법은 각종 구문(연산자, 키워드)들을 서로 잘  끼워 맞춰 규칙에 맞는, 유효한 프로그램을 만들기 위한, 구조적 방법이다. 개발자들이 직접 마주할 대상은 있는 그대로의 언어 구문이지만 이 장에서는 최대한 정확한 문법을 기술하는데 초첨을 둘 것이다. 

* [5-1 문과 표현식](#5-1-문과-표현식)
* [5-2 연산자 우선순위](#5-2-연산자-우선순위)
* [5-3 세미클론 자동 삽입](#5-3-세미클론-자동-삽입)
* [5-4 에러](#5-4-에러)
* [5-5 함수 인자](#5-5-함수-인자)
* [5-6 try finally](#5-6-try-finally)
* [5-7 switch](#5-7-switch)
* [5-8 정리하기](#5-8-정리하기)

## 5-1 문과 표현식

자바스크립트에서 문(Statement)과 표현식(Expression)은 아주 주용한 차이가 있으므로 명확하게 분별하자.

영어에 대입해보면 문(Statement)은 문장(Sentence), 표현식(Expression)은 어구(Phrase), 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다.

```js
var a = 3 * 6;
var b = a;
b;
```

3가지 모두 표현식. 그리고 표현식이 포함된 문.

var a= 3 * 6, var b = a 두 문은 각각 변수를 선언(그리고 어떤 값으로 할당)하므로 '선언문'이라 한다.
(앞에 var가 빠진) a = 3 * 6, b = a 는 '할당 표현식'이라고 한다.

세 번째 줄 b 는 '표현식 문'이라고 일컫는다.

### 5-1-1 문의 완료 값

모든 문은 (값이 undefined라 해도) 완료 값(Completion Value)을 가진다는 사실을 의외로 모르는 사람이 많다.

문의 완료 값을 확인하는 방법은 브라우저 개발자 콘솔 창에서 문을 타이핑해보는 것이다. 콘솔 창은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력하게 되어 있다.

var b = a 같은 문은 완료 값이 뭘까?

할당 표현식 b = a는 할당 이후의 값(여기서는 18)이 완료 값이지만, var 문 자체의 완료 값은 udefined다. 명세에 그렇게 적혀있기 때문이다.

완료 값을 순간 포착할 방법은 없을까? 근데 왜 꼭 그래야하는지부터 생각하자.

예를 들어, 보통의 { } 블록은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료 값으로 반환한다.

```js
var b;

if (true) {
	b = 4 + 38;
}
```

b = 4 + 38의 완료값인 42가 반환된다.

즉, 블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.

하지만 다음과 같은 코드가 작동하지 않는 건 문제가 있다.

```js
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

문의 완료 값을 포착하여 다른 변수에 할당한다는 건 쉬운 구문/문법으로는 불가능하다.

*예를 들기 위함이니 아래 코드는 실제로 사용하지 말자*

유해함의 대명사 eval() 함수를 사용할 수 밖에 없다.

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

꼴보기 싫은 코드지만 잘 돌아간다!

ES7 명세에는 'do 표현식'이 제안된 상태다.

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

do { } 표현식은 (하나 이상의 문을 포함한) 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.

아직까지는 문 완료 값을 대수롭지 않게 여기고 있지만 자바스크립트 언어가 진화할수록 그 중요성은 점점 더 부각될 것 같다.

다시 경고하지만 eval()은 사용하지 말자. 자세한 내용은 2부 스코프와 클로져를 참고하자.

### 5-1-2 표현식의 부수 효과

대부분의 표현식에는 부수 효과가 없다.

```js
var a = 2;
var b = a + 3;
```

표현식 a + 3 자체는 가령 a 값을 바꾸는 등의 부수 효과가 전혀 없다. 단지 b = a + 3 문에서 결괏값 5가 b에 할당될 뿐이다.

다음의 함수 호출 표현식은 부수 효과를 가진(가졌을지 모를) 표현식의 전형적인 예다.

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// 결괏값: `undefined`, side effect: `a` 가 변경됨.
```

다른 부수 효과를 지닌 표현식.

```js
var a = 42;
var b = a++;
```

표현식 a++이 하는 일은 두 가지다. a의 현재 값 42를 반환(그리고 b에 할당하는 것까지)하고 a 값을 1만큼 증가시킨다.

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

여기서 b 값을 43으로 착각하는 개발자들이 생각보다 많다. 부수효과가 있다는 걸 잘몰라서

```js
var a = 42;

a++;	// 42
a;		// 43

++a;	// 44
a;		// 44
```

++를 전위 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 부수 효과를 일으킨다. 반면, 후위 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.

NOTE: ++a++ 는 문법에 맞는 구문일까? Reference Error 발생. 부수 효과를 유발하는 연산자는 부수 효과를 일으킬 변수 레퍼런스가 꼭 필요하기 떄문이다. 우선순위 규칙에 의해 a++가 먼저 실행되어 42를 반환한다. ++ 연산자는 42 같은 원시 값에 부수 효과를 일으킬수 없으므로 ReferenceError를 던진다.

a++를 ()로 감싸면 후위 부수 효과를 캡슐화할 수 있다고 착각하는 경우도 더러 있다.

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

() 둘러싼다 해도 a++ 표현식에서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다.

하지만 문을 나열하는 콤마 연산자 , 를 사용하면 다수의 개별 표현식을 하나의 문으로 연결할 수 있다.

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

NOTE: 뒷부분에서 다시 얘기 하겠지만 ( a++ , a ) 에서 괄호를 빠뜨리면 안된다.

두번째 a 표현식을 첫 번째  a++ 표현식에서 부수 효과가 발생한 이후에 평가한다. 그래서 b 값은 43이다.

delete 역시 부수 효과를 일으키는 연산자다. delete는 객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 쓴다. 하지만 단독 문으로 더 많이 쓴다.

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

delete 연산자의 결괏값은 유효한/허용된 연산일 경우 true, 그 외에는 false다. 이 연산자의 부수 효과는 바로 프로퍼티(또는 배열 슬롯)을 제거하는 것이다.

NOTE: '유효한/허용된'의 의미. 존재하지 않는 프로퍼티 또는 존재하면서 설정 가능한 프로퍼티일 경우, delete 연산자는 true를 반환. 그 외의 경우는 false를 반환.(this와 프로토타입, 비동기와 성능 참고)

마지막 예시는 = 할당 연산자.

```js
var a;

a = 42;		// 42
a;			// 42
```

42를 a에 할당하는 자체가 본질적으로 부수 효과다.

이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 다음과 같은 연쇄 할당문에서 특히 유용하다.

```js
var a, b, c;

a = b = c = 42;
```

c = 42 평가 결과는 (42를 c에 할당하는 부수 효과를 일으키며) 42가 되고, b = 42 평가 결과는 (42를 b에 할당하는 부수 효과를 일으키며) 42가 된다. 결국, a = 42로 (42를 a에 할당하는 부수 효과를 일으키며) 평가 된다.

NOTE: var a= b = 42 처럼 연쇄 할당문을 잘못 쓰는 경우가 많다. 변수 b를 선언하지 않은 상태에서 실행하면 이 할당문은 b를 직접 선언하지 않는다. 대신, 엄격 모드 여부에 따라 에러가 나거나 원치 않는 전역 변수가 생성된다.

```js
function vowels(str) {
	var matches;

	if (str) {
		// 모든 모음을 추출한다.
		matches = str.match( /[aeiou]/g );

		if (matches) {
			return matches;
		}
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

잘 동작한다. 많은 개발자가 이렇게 작성한다. 할당 연산자의 부수 효과를 잘 활용하면 다음과 같이 2개의 if 문을 하나로 간단히 합칠 수 있다.

```js
function vowels(str) {
	var matches;

	// 모든 모음을 추출한다.
	if (str && (matches = str.match( /[aeiou]/g ))) {
		return matches;
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

 NOTE: matches = str.match( /[aeiou]/g) 를 감싸는 ( )를 빠뜨리면 안된다.

 두 조건이 서로 분명히 연관되어 있음을 잘 보여주기 때문에 필자는 후자를 더 선호하는 편이다. 물론 취향 차이. 

### 5-1-3 콘텍스트 규칙

같은 구문이지만 어디에서 어떤 식으로 사용하느냐에 따라 서로 다른 의미를 가지는 경우가 있다. 하나씩 떨어뜨려 놓고 보면 상당히 헷갈리 수 있다.

자주 나오는 몇 가지 사례를 살펴보자.

#### 중괄호

자바스크립트에서 중괄호 {}가 나올 법한 곳은 크게 두 군데다.

#### 객체 리터럴

첫째, 객체 리터럴이다.

```js
// `bar()` 함수는 앞에 정의되었다.

var a = {
	foo: bar()
};
```

{ }는 a에 할당될 값이므로 객체 리터럴이 맞다.

NOTE: 래퍼런스 a는 할당의 대상이므로 'ㅣ 값 L-Value'(좌측 lefthand 값), { }는 할당의 원본 값이므로 'r 값 R-Value'(우측 Righthand 값)이라고도 한다.

#### 레이블

방금전 코드에서 var a = 부분을 삭제하면 어떻게 될까?

```js
// `bar()` 함수는 앞에 정의도었다.

{
	foo: bar()
}
```

{ }는 어디에도 할당되지 않은, 그저 고립된 객체 리터럴처럼 보인다. 하지만 전혀 그렇지 않다.

여기서의 { }는 평범한 코드 블록이다. 특히 let 블록 스코프 선언과 함께 쓰이면 아주 유용하다. (2부 스코프와 클로저 참고.)

이 { } 코드 블록은 for/while 루프, if 조건 등에 붙어있는 코드 블록과 기능적으로 매우 유사하다.

근데 foo: bar()가 특이하게 보이는데 어떻게 이런 코드가 문법에 부합하나?

그건 자바스크립트에서 '레이블 문(Labled Statement)'이라는 기능 덕분이다.(솔직히 비권장) 즉 foo는 bar() 문의 레이블이다.

자바스크립트는 제한적이기는 해도 레이플 점프라는 특별한 형태의 goto 장치가 대신 마련되어 있다. continue와 break 문은 선택적으로 어떤 레이블을 받아 goto처럼 프로그램의 실행 흐름을 'jump' 시킨다.

```js
// `foo` 레이블 루프
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// 두 루프의 반복자가 같을 때마다 바깥쪽 루프를 continue 한다.
		if (j == i) {
			// 다음 순회 시 'foo' 붙은 루프로 점프한다.
			continue foo;
		}

		// 홀 수 배 수는 건너 뛴다.
		if ((j * i) % 2 == 1) {
			// 평범한 (레이블 없는) 안쪽 루프의 `continue`
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

NOTE: continue foo는 "foo라는 레이블 위치도 이동하여 계속 순회라"는 의미가 아니라 *"foo라는 레이블이 붙은 루프의 다음 순회를 계속하라"*라는 뜻이다. 따라서 사실 임의적인 goto와는 다르다.

아마도 바깥쪽 루프로 나가야 할 지점에 안쪽 푸르에서 break __ 처럼 사용해야 레이블 루프 점프로 좀 더 잘 활용하는 모습이 될 것 같다.

```js
// `foo` 레이블 루프
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "그만!", i, j );
			// `foo` 레이블 루프에서 벗어나다
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// 그만! 1 3
```

break foo는 "foo라는 레이블 위치로 이동하여 계속 순회하라"는 의미가 아니라, "foo라는 레이블이 붙은 바깥쪽 루플/블록 밖으로 나가 그 이후부터 계속하라"는 뜻이다. 역시 전통적인 goto와는 의미가 사뭇 다르다.

방금전 예제를 레이블 없는 break로 작성하려면 코드가 더 복잡해지고 혼란스러워질 수 있다. 따라서 이런 경우라면 레이블 break 사용이 더 나은 선택이라 할 수 있다.

레이블은 비 루프 브록에 적요할 수 있다. 단 이런 비 루프 레이블은 break만 참조 할 수 있다.(continue __, 레이블 없는 break 사용 불가)

```js
function foo() {
	// `bar` 레이블 블록
	bar: {
		console.log( "Hello" );
		break bar;
		console.log( "절대 실행 안됨" );
	}
	console.log( "World" );
}

foo();
// Hello
// World
```

레이블 루프/블록은 사용빈도가 극히 드물고 못마땅한 구석도 많아 가능한 한 피하는게 상책이다. 이를테면 루프 점프를 할 바에야 차라리 함수 호출이 더 낫다. 하지만 제한적이나마 도움이 되는 경우가 없지 않으므로, 만약 사용하게 된다면 여러분이 뜻한 바를 상세한 주석으로 잘 문서화 하자.

JSON은 자바스크립트 구문의 하위 집합이라 할 수 있지만, 그 자체로 올바른 자바스크립트 문법은 아니다. (가령 JSON 문자열 {"a":42}를 콘솔 창에 입력하면 에러 발생. 자바스크립트 문의 레이블은 따옴표로 감싸면 안되기 때문)

JSON 문자열로만 가득 채워진 파일을 \<script src=...> 태그로 읽어 들여도 정상적인 자바스크립트 코드로 인식될 거라고 흔히 오해한다. 하지만 이런 파일은 프로그램에서 접근조차 할 수 없다. 그래서 보통 JSON-P(JSON 데이터를 함수 호출로 감싸는 패턴) 방식으로 접근이 안되는 문제를 해결 할 수 있다고 한다.

정확한 해석은 이렇다. {"a":42}는 완전히 올바른 JSON 값이지만, 그 자체로는 레이블이 잘못된 문 블록으로 해석되어 에러가 난다. 하지만 foo({"a":42})는 함수 내부에서 {"a":42}가 foo()에 전달된 객체 리터럴이므로 유효한 자브스크립트 코드다. 따라서 JSON-P가 JSON을 문법에 맞는 자바스크립트 코드로 옷을 갈아입혀 주는 셈이다.

#### 블록

```js
[] + {}; // "[object Object]"
{} + []; // 0
```

마치 + 연산자가 첫 번째 피연산자에 따라 ([]/{}) 다른 결과를 내놓는 것처럼 보인다. 하지만 실제로는 전혀 상관없다!

윗 줄에서는 {}를 실제 값(빈 객체)으로 해석한다. []는 {}로 강제변환되고 {}도 문자열 "[object Object]"로 강제변환된다.

아랫 줄의 {}는 빈 블록으로 간주한다. 결국 + [] 표현식에서 명시적으로 []를 숫자 0으로 강제변환한다.

#### 객체 분해

ES6 부터는 '분해 할당(Destructing Assignment)', 구체적으로는 객체 분해 시 { } 를 사용한다.

```js
function getData() {
	// ..
	return {
		a: 42,
		b: "foo"
	};
}

var { a, b } = getData();

console.log( a, b ); // 42 "foo"
```

var { a, b } = ... 이 ES6 분해 할당의 형식이며, 의미는 대략 다음 코드와 같다.

```js
var res = getData();
var a = res.a;
var b = res.b;
```

{ } 를 이용한 객체 분해는 명명된 함수에도 활용할 수 있다.

```js
function foo({ a, b, c }) {
	// 다음 코드 처럼 할 필요가 없다.
	// var a = obj.a, b = obj.b, c = obj.c
	console.log( a, b, c );
}

foo( {
	c: [1,2,3],
	a: 42,
	b: "foo"
} );	// 42 "foo" [1, 2, 3]
```

#### else if 와 선택적 블록

다음 코드가 잘 작동한다고 해서 자바스크립트에 else if 절이 존재한다고 믿지 마쇼.

```js
if (a) {
	// ..
}
else if (b) {
	// ..
}
else {
	// ..
}
```

실은 else if 같은 건 없다. if와 else 문은 실행문이 하나밖에 없는 경우 블록을 감싸는 { }를 생략해도 된다.

```js
if (a) doSomething( a );
```

여러 스타일 가이드 문서에는 다음처럼 단일 문 블록도 { }로 감싸라고 조언한다.

```js
if (a) { doSomething( a ); }
```

정확히 동일한 문법 규칙이 else 절에도 적용된다.

```js
if (a) {
	// ..
}
else {
	if (b) {
		// ..
	}
	else {
		// ..
	}
}
```

else 이후의 if (b) { } else { }는 단일 문이므로 { }로 감싸든 말든 상관 없다.

즉, else if 라고 쓰는 건 표준 스타일 가이드의 위반 사례가 되며, 단일 if 문과 같이 else를 정의한 셈이 된다.

어떤 식으로 코딩하든 여러분 자신의 스타일 가이드와 규칙을 명시적으로 준수하고 else if를 정확한 문법 규칙인 양 넘겨짚지는 말자.

## 5-2 연산자 우선순위

표현식에 연산자가 여러 개 있을 경우 어떤 규칙으로 처리되는지 알아야 한다.

바로 이 규칙을 '연산자 우선순위(operator precedence)'라고 한다.

앞에서 한번 봤던 예제다.

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

( )를 없애면 결과는 달라질까?

```js
var a = 42, b;
b = a++, a;

a;	// 43
b;	// 42
```

b의 결과가 바뀌었다.

이유는 , 연산자가 = 연산자보다 우선순위가 낮기 때문이다. 그러므도 (b = a++), a로 해석한다.

다수의 문을 연결하는 연산자로 ,를 사용할 때에는 이 연산자의 우선순위가 최하위다. *즉 어떤 연산자라도 , 보다 먼저 묶인다.*

다른 예제를 보자.

```js
if (str && (matches = str.match( /[aeiou]/g ))) {
	// ..
}
```

할당문 양쪽을 ( )로 감싸야한다. *&&가 =보다 우선순위가 높으므로* ( )로 묶어주지 않으면 표현식은 (str && matches) = str.match...로 처리 된다. (str && matches)는 저상적인 변수가 아닌, 어떤 값(여기서는 undefined)으로 평가되는데 = 할당 연산자 좌측에 값이 나오는 건 어불성설이므로 에러가 난다.

이번에는 좀 더 복잡한 예제.

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b || c ? c || b ? a : c && b : a;

d;		// ??
```

이 코드를 보면서 다수의 연산자를 체이닝(아주 흔한 작업이다) 할 경우의 이슈를 연구해보자.

결과는 42다.

첫째, '제일 앞의 a && b || c 가 (a && b) || c 와 a && (b || c) 중 어느 쪽으로 해석될까?

```js
(false && true) || true;	// true
false && (true || true);	// false
```

그렇다, 분명 다르다. 그럼 false && true || true 의 결과는?

```js
false && true || true;		// true
(false && true) || true;	// true
```

&& 연산자가 먼저 평가되고 || 연산자가 그 다음에 평가된다.

처리 방향 대문에? 순서를 바꿔보자.

```js
true || false && false;		// true

(true || false) && false;	// false -- 아니네
true || (false && false);	// true -- 맞다!
```

여기까지 해서 &&는 언제나 || 보다 먼저 평가된다는 사실이 증명됐다.

왜? 연산자 우선순위 규칙 때문에.

NOTE: 전체 연산자 운선순위 리스트 [링크](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84)

### 5-2-1 단락 평가

&&, || 연산자는 좌측 피연산자의 평가 결과만으로 전체 결과가 이미 결정될 경우 우측 피연산자의 평가를 건너뛴다. 그래서 '단락(Short Circuited)'이란 말이 유래된 것이다.(가능한 한 빨리 지름길을 택한다)

예를 들어 a && b 에서 a가 falsy면 b는 쳐다보지도 않는다. a || b 에서 a가 truthy면, 이미 전체 결괏값은 true로 확정되므로 b는 관심을 둘 이유가 없다.

단락 평가는 아주 유용하고 자주 쓰인다.

```js
function doSomething(opts) {
	if (opts && opts.cool) {
		// ..
	}
}
```

opts && opts.cool에서 opts는 일종의 가드다. 만약 opts가 존재하지 않는다면(아니면 객체가 아니라면) 당연히 opts.cool 표현식은 에러일 수 밖에 없다. 일단 opts를 먼저 단락 평가해보고, 그 결과가 실패면 opts.cool은 자동으로 건너뛰니 결과적으로 에러는 나지 않는다.

|| 단락 평가도 마찬가지다.

```js
function doSomething(opts) {
	if (opts.cache || primeCache()) {
		// ..
	}
}
```

opts.cache를 먼저 체크해서 OK면, primeCache() 함수는 호출하지 않고 넘어 갈 수있다. 그래서 불필요한 작업이 줄어든다.

### 5-2-2 Tighter Binding

삼항 연산자 ? : 부분을 잘 보기 바란다. ? : 는 && 와 || 보다 우선순위가 높을까 아니면 낮을까?

```js
a && b || c ? c || b ? a : c && b : a
```

다음 둘 중 어느 쪽으로 처리 될까?

```js
a && b || (c ? c || (b ? a : c) && b : a)
(a && b || c) ? (c || b) ? a : (c && b) : a
```

정답은 아랫 줄이다.

&&는 || 보다, || 는 ? : 보다 각각 우선순위가 높기 때문이다.

즉, &&와 || 는 ? : 보다 'bind more tightly'을 나눈 사이라고 할 수 있다.

### 5-2-3 결합성

우선순위가 동일한 다수의 연산자라면 처리 순서가 어떻게 될까?

일반적으로 연산자는 좌측부터 그룹핑이 일어나는지 우측부터 그룹핑이 일어나는지에 따로 좌측 결합성 또는 우측 결합성을 가진다.

여기서 결합성(Associativity)이란 문제는 처리방향(좌->우 or 우->좌)을 정하는 문제와 전혀 다르다.

그럼 처리 방향이 왜 중요할까? 다음 함수 호출과 같이 표현식이 부수 효과를 일으킬 수 있기 때문이다.

```js
var a = foo() && bar();
```

foo() 함수를 먼저 호출한 뒤, 그 결괏값에 따라 bar() 호출 여부를 결정한다. 만일 bar()가 foo() 앞에 있다면 전혀 다른 식으로 프로그램이 흘러갈 것이다.

foo() 함수가 먼저 호출되는 건 단순히 좌측 -> 우측 순서로 처리(자바스크립트의 기본 처리 순서다)되니 그런 것이지 &&의 결합성과는 무관하다.

그러나 a && b && c 같은 표현식에서는 암시적인 그룹핑이 발생한다. 즉, a && b 와 b && c 중 어느 한 편이 먼저 평가된다.

&&는 좌측부터 결합하므로(||도 마찬가지) (a && b) && c 와 같다. 설사 우측부터 결합하여 a && (b && c) 라도 결과가 같다. 동일한 값에 대하여 동일한 표현식은 항상 동일한 순서로 평가된다.

하지만 결합 방향이 좌/우측 어느 쪽인지에 따라 와넞ㄴ히 다르게 작동하는 연산자도 있다.

우선 ? : ('삼항' 또는 '조건') 연산자가 그렇다.

```js
a ? b : c ? d : e;
```

? : 는 우측 결합성 연산자인데, 그럼 다음 둘 중 정답은?

```js
a ? b : (c ? d : e)
(a ? b : c) ? d : e
```

윗줄 a ? b : (c ? d : e) 다. &&, || 와는 달리, 우측부터 결합하므로 결과가 달라진다.

다음 조합도 그렇다.

```js
true ? false : true ? true : true;		// false

true ? false : (true ? true : true);	// false
(true ? false : true) ? true : true;	// true
```

결괏값은 같은데 좀 더 복잡 미묘한 차이가 숨겨진 조합도 있다.

```js
true ? false : true ? true : false;		// false

true ? false : (true ? true : false);	// false
(true ? false : true) ? true : false;	// false
```

어차피 최종 결과는 같으니 그룹핑은 그다지 문제 될 게 없어 보인다. 그러나,

```js
var a = true, b = false, c = true, d = true, e = false;

a ? b : (c ? d : e); // false, `a` 와 `b` 만 평가
(a ? b : c) ? d : e; // false, `a`, `b` 그리고 `e`를 평가
```

? : 연산자는 연쇄적으로 맞물릴 때 조심하지 않으면 문제가 될 수 있음을 알 수 있다.

=도 우측 결합성(그룹핑) 연산자 중 하나다. 전에 봤던 연쇄 할당문 예제를 보자.

```js
var a, b, c;

a = b = c = 42;
```

우측부터 결합하기 때문에 실제로 엔진은 a = (b = (c = 42)) 처럼 해석한다.

복잡한 할당 표현식으로 보자.

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b || c ? c || b ? a : c && b : a;

d;		// 42
```

이제 우선순위와 결합성을 배웠으니 다음과 같이 해석됨을 알 수 있다.

```js
((a && b) || c) ? ((c || b) ? a : (c && b)) : a
```

알아보기 쉽게 들여 쓰기를 해보자.

```js
(
  (a && b)
    ||
  c
)
  ?
(
  (c || b)
    ?
  a
    :
  (c && b)
)
  :
a
```

한 단계씩 풀어보자.

1. (a && b)는 "foo"다.
2. "foo" || c 는 "foo"다.
3. 첫 번째 삼항 연산, "foo"는 truthy? -> 맞다.
4. (c || b)는 "foo"다.
5. 두 번째 삼항 연산, "foo"는 truthy? -> 맞다.
6. a = 42 다.

그래서 답은 42다.

### 5-2-4 분명히 하자

이 모든 연산자 우선순위/결합성을 코드를 볼 사람이 모조리 다 꿰고 있다는 전제하에 코딩을 해야 할까? 임의로 처리 순서나 바인딩을 다르게 가져가고자 할 때에만 ( )로 손수 그룹핑을 하는게 맞을까?

개인적으로는 중용이 중요하다고 생각한다. 두 방법을 여러분의 프로그램에 적절히 배합하는 것이다.

결론은 4장 강제변환과 대동소이하다. 연산자 우선순위/결합성을 적절히 활용하여 짧고 깔끔한 코드를 작성하되 혼동을 줄이고 분명히 밝혀야 할 부분은 ( )로 예쁘게 감싸 주기 바란다.

## 5-3 세미클론 자동 삽입

ASI(Automatic Semiclon Insertion)는 자바스크립트 프로그램의 세미클론(;)이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다.

단, ASI는 새 줄(행 바꿈 Line Break)에만 적용되면 어떠한 경우에도 줄 중간에 삽입되는 일은 없다.

기본적으로 자바스크립트 파서는 줄 단위로 파싱을 하다가 (;이 빠져) 에러가 나면 ;을 넣어보고 타당한 것 같으면 ;를 삽입한다.

```js
var a = 42, b
c;
```

엔진은 b 뒤에 (새 줄에) 암시적으로 ;을 삽입한다. 따라서 c;는 독립적인 표현식 문이 된다.

```js
var a = 42, b = "foo";

a
b	// "foo"
```

표현식 문에도 ASI가 잘 적용되므로 에러 없는 유효한 프로그램이다.

다음 예제를 보면 ASI가 참 유용하다는 사실을 알 수 있다.

```js
var a = 42;

do {
	// ..
} while (a)	// <-- ;를 빼먹었군!
a;
```

while, for 루프와 달리 do while 루프는 마지막에 ;을 넣어야 문법적으로 맞다. ASI는 친절하게 처리해준다.

앞서 예기했듯이 문 블록에서 ;는 필수가 아니므로 ASI 역시 필요 없다.

```js
var a = 42;

while (a) {
	// ..
} // <-- ;는 필요 없군!
a;
```

ASI는 주로 break, continue, return, yield(ES6부터) 키워드가 있는 곳에서 활약한다.

```js
function foo(a) {
	if (!a) return
	a *= 2;
	// ..
}
```

return 문이 다음 줄 a *= 2 표현식으로 건너갈 일은 없으니 ASI는 return 문 끝에 ;을 추론하여 삽입한다.

아래와 같이 return 문을 여러 줄에 걸쳐 표기할 수도 있다.

```js
function foo(a) {
	return (
		a * 2 + 3 / 12
	);
}
```

return 다음에 새 줄/행 바꿈 문자만 있는 경우는 안된다.

```js
function foo(a) {
	return // return;으로 해석하여 undefined가 반환됨.
		a * 2 + 3 / 12
	;
}
```

break, continue, yield에도 동일한 추론 로직이 적용된다.

### 5-3-1 에러 정정

자바스크립트 커뮤니티에서 가장 뜨거운 논란거리는 ASI에 전적으로/완전히 의존해야 하는 가다.

대부분 세미클론은 선택 사항이다(for( ; ;) 처럼 필수 세미클론도 있다).

ASI 찬성 측 개발자들은 ASI가 보다 간결한 코드를 작성하게 도와주는 아주 유용한 도구라고 주장한다.

반면, 반대 측에서는 개발자가 의도하지 않은 ;들이 삽입되면서 그 의미가 달라질 수 있고, 비숙련 개발자들의 경우 실수할 가능성이 높다고 말한다.

명세에는 분명히 ASI가 '에러 정정(Error Corretion)' 루틴이라고 씌어 있다. 여기서 에러란 구체적으로 파서 에러(Passer Error)다. 다른 말로 풀이하면 ASI가 파서를 너그럽게하여 에러를 줄이는 것이다.

저자의 결론은 이렇다. '필요하다고' 생각되는 곳이라면 어디든지 세미클론을 사용하고, ASI가 어떻게든 뭔가 해줄 거라는 가정은 최소화하자.

ASI가 마치 유효 개행 문자를 넣어주는 것처럼 착각하지 않기 바란다.

## 5-4 에러

자바스크립트에는 하위 에러 타입(TypeError, ReferenceError, SyntaxError 등)뿐만 아니라, (에러는 대부분 런타임 시점에 발생하지만) 일부 에러는 컴파일 시점에 발생하도록 문법적으로 정의되어 있다.

특히 자바스크립트에는 오래 전부터 (컴파일 도중) '조기 에러(Early Error)'로 붙잡아 던지게 되어 있는, 여러 가지 특정 조건들이 있었다. 한눈에 봐도 알 수 있는 구무 에러(예: a = ,)는 물론이고, 자바스크립트 문법에는 구문상 오류는 아니지만 허용되지 않는 것들로 정의되어 있다.

코드가 실행도 되기 전에 발생하므로 이런 에러는 try catch로 잡을 수 없으며, 그냥 프로그램 파싱/컴파일이 실패한다.

다음 정규 표현식 리터럴 내부의 구문이 그런 예다. 자바스크립트 구문상 아무 문제가 없지만 올바르지 않은 정규 표현식은 조기 에러를 던진다.

```js
var a = /+foo/;		// 에러!
```

할당 대상은 반드시 식별자(또는 하나 이상의 식별자를 가져오는 ES6 분해 표현식)여야 한다.

```js
var a;
42 = a;		// 에러!
```

ES5 엄격 모드는 조기 에러가 더 많다. 예컨데 엄격 모드에서 함수 인자명은 중복될 수 없다.

```js
function foo(a,b,a) { }					// 정상 실행!

function bar(a,b,a) { "use strict"; }	// 에러!
```

동일한 이름의 프로퍼티가 여러 개 있는 객체 리터럴도 사정은 비슷하다.

```js
(function(){
	"use strict";

	var a = {
		b: 42,
		b: 43
	};			// 에러!
})();
```

### 5-4-1 너무 이른 변수 사용

ES6는 '임시 데드 존 TDZ, Temporal Dead Zone'이라는 새로운 개념을 도입했다.

TDZ는 아직 초기화를 하지 않아 변수를 참조할 수 없는 코드 영역이다.

ES6 let 블록 스코핑이 대표적인 예다.

```js
{
	a = 2;		// ReferenceError!
	let a;
}
```

let a 선언에 의해 초기화되기 전 a =  2 할당문이 ({ } 블록 스코프 안에 있는) 변수 a에 접근하려고 한다. 하지만 a는 아직 TDZ 내부에 있으므로 에러가 난다. let a;를 실행 후에 TDZ가 끝나고 a에 undefineㅇ가 할당된다.

typeof 연산자는 선언되지 않은 변수 앞에 붙여도 오류는 나지 않는데 TDZ 참조 시에는 이러한 안전장치가 없다. TDZ에 위치하여 접근할 수가 없기 때문.

```js
{
	typeof a;	// undefined
	typeof b;	// ReferenceError! (TDZ)
	let b;
}
```

## 5-5 함수 인자

TDZ 관련 에러는 ES6 디폴트 인자 값에서도 찾아볼 수 있다.

```js
var b = 3;

function foo( a = 42, b = a + b + 5 ) {
	// ..
}
```

두 번째 할당문에서 좌변 b는 아직 TDZ에 남아 있는 b를 참조하려고 하기 때문에 (더 바깥쪽에서 끌어오지 못하고) 에러를 던진다. 그러나 이 시점에서 인자 a는 TDZ를 밝고 간 이후여서 문제가 없다. 함수 인자의 디폴트 값은 마치 하나씩 좌측 -> 우측 순서로 let 선언을 한 것과 동일하게 처리된다. 그래서 일단 무조건 TDZ에 속하게 된다.

ES6 디폴트 인자 값은 함수에 인자를 넘기지 않거나 undefined를 전달했을 때 적용된다.

```js
function foo( a = 42, b = a + 1 ) {
	console.log( a, b );
}

foo();					// 42 43
foo( undefined );		// 42 43
foo( 5 );				// 5 6
foo( void 0, 7 );		// 42 7
foo( null );			// null 1
```

ES6 디폴트 인자 입장에서 보면 인자 값이 없거나 undefined 값을 받거나 그게 그거다. 하지만 차이점을 엿볼 수 있는 경우도 있다.

```js
function foo( a = 42, b = a + 1 ) {
	console.log(
		arguments.length, a, b,
		arguments[0], arguments[1]
	);
}

foo();					// 0 42 43 undefined undefined
foo( 10 );				// 1 10 11 10 undefined
foo( 10, undefined );	// 2 10 11 10 undefined
foo( 10, null );		// 2 10 null 10 null
```

undefined 인자를 명시적으로 넘기면 arguments 배열에도 값이 undefined인 원소가 추가되는데, 여기에 해당하는 디폴트 인자 값과 다르다.

ES6 디폴트 인자 값이 arguments 배열 슬롯과 이에 대응하는 인자 값 간의 불일치를 초래하는 것은 사실이지만 이전 버전 ES5에서도 똑같은 불일치는 교묘하게 발생한다.

```js
function foo(a) {
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 42 (연결됨)
foo();		// undefined (연결 안됨)
```

인자를 넘기면 arguments의 슬롯과 인자가 연결되면서 항상 같은 값이 할당되지만 인자 없이 호출하면 전혀 연결되지 않는다.

더욱이 엄격 모드에서는 어떻게 해도 연결되지 않는다.

```js
function foo(a) {
	"use strict";
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 2 (연결 안됨)
foo();		// undefined (연결 안됨)
```

이렇게 확실하지 않은 연결에 의존하여 코딩하는 것은 바람직하지 않은 것 같다. 사실 엔진 내부의 상세한 구현체를 노출시킨, 구멍난 추상화다.

arguments 배열은 이제 비 권장 요소지만(특히 ES6부터는 Rest 인자를 권장한다.), 그렇다고 완전히 나쁜 것은 아니다.

"인자와 이 인자에 해당하는 arguments 슬롯을 동시에 참조하지 마라"라는 간단한 규칙만 준순한다면 안전하다.

```js
function foo(a) {
	console.log( a + arguments[1] ); // 안전하다!
}

foo( 10, 32 );	// 42
```

## 5-6 try finally

finally 절의 코드는 (어떤 일이 있어도) 반드시 실행되고 다른 코드로 넘어가기 전에 try 이후부터 (catch가 있으면 catch 다음부터) 항상 실행된다. 어떤 의미에서 finally 절은 다른 블록 코드에 상관없이 필히 실행되어야 할 콜백 함수와 같다고 봐야 맞다.

그런데 만약 try 절에 return 문이 있으면? 당연히 어떤 값을 반환할 텐데, 그 값을 반환받은 호출부 코드는 finally 이전에 실행될까? 아니면 이후에 실행될까?

```js
function foo() {
	try {
		return 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "실행될리 없음" );
}

console.log( foo() );
// Hello
// 42
```

return 42에서 foo() 함수의 완료 값은 42로 세팅된다. try 절의 실행이 종료되면서 곧 바로 finally 절로 넘어간다. 그 후 foo() 함수 전체의 실행이 끝나고 완료 값(return 42)은 호출부 console.log()문에 반환된다.

try 안에 throw가 있어도 비슷하다.

```js
 function foo() {
	try {
		throw 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// Uncaught Exception: 42
```

하지만 만약 finally 절에서 예외가 던져지면, 이전의 실행 결과는 모두 무시한다. 즉, 이전에 try 블로에서 생성한 완료 값이 있어도 완전히 사장된다.

```js
function foo() {
	try {
		return 42;
	}
	finally {
		throw "웁스!";
	}

	console.log( "절대 실행 안됨" );
}

console.log( foo() );
// Uncaught Exception: 웁스!
```

continue나 break 같은 비선형(Nonlinear) 제어문 역시 return과 throw와 비슷하게 작동한다.

```js
for (var i=0; i<10; i++) {
	try {
		continue;
	}
	finally {
		console.log( i );
	}
}
// 0 1 2 3 4 5 6 7 8 9
```

continue 문 때문에 console.log(i) 문은 루프 순회 끝 부분에서 실행된다. 그러나 i++로 인덱스가 수정되기 직전까지 꾸준히 실행되므로 0 ~ 9가 콘솔 창에 표시된다.

finally 절의 return은 그 이전에서 실행된 try나 catch 절의 return을 덮어쓰는 특출한 능력을 갖고 있는데, 단 *반드시 명시적으로 return 문을 써야 한다.*

```js
function foo() {
	try {
		return 42;
	}
	finally {
		// `return ..` 이 없네, override 하지 말자
	}
}

function bar() {
	try {
		return 42;
	}
	finally {
		// 기존의 `return 42` 를 override
		return;
	}
}

function baz() {
	try {
		return 42;
	}
	finally {
		// 기존의 `return 42` 를 override
		return "Hello";
	}
}

foo();	// 42
bar();	// undefined
baz();	// "Hello"
```

보통 함수에서는 return을 생략해도 return; 또는 return undefined; 한 것으로 치지만, finally 안에서 return을 빼면 이전의 return을 무시하지 않고 존중한다.

레이블 break와 finally가 만나면 그야말로 장관이다.

```js
function foo() {
	bar: {
		try {
			return 42;
		}
		finally {
			// `bar` 레이블 블록으로 나간다
			break bar;
		}
	}

	console.log( "미침?" );

	return "Hello";
}

console.log( foo() );
// 미침?
// Hello
```

부디 이런 코딩은 피하자.

## 5-7 switch

```js
switch (a) {
	case 2:
		// 뭔가 하고
		break;
	case 42:
		// 다른거 하고
		break;
	default:
		// 아무것도 안걸리면 여기로
}
```

switch에는 여러분이 예전에는 몰랐을 내용이 있다.

첫째, swich 표현식과 case 표현식 간의 매치 과정은 === 알고리즘(4장 강제변환 참고)과 똑같다. 예제처럼 case 문에 확실한 값이 명시된 경우라면 엄격한 매치가 적절하다.

그러나 강제변환이 일어나는 동등 비교(==)를 이용하고 싶다면 switch 문에 꼼수를 좀 부려야 한다.

```js
var a = "42";

switch (true) {
	case a == 10:
		console.log( "10 or '10'" );
		break;
	case a == 42:
		console.log( "42 or '42'" );
		break;
	default:
		// 여기 올 일은 없지
}
// 42 or '42'
```

어쨋든 case 절에 (단순 값은 아니지만) 표현식이 있으니 실행상 문제는 없다. 즉, switch 표현식의 결과(true)와 case 표현식의 결과를 엄격하게 매치한다. a == 42는 true이므로 여기서 매치된다.

==를 써도 switch 문은 엄격하게 매치한다. 그래서 case 표현식 평가 결과가 truthy이지만 엄격히 true는 아닐 경우 매치는 실패한다. 이를테면 표현식에 && 나 || 같은 '논리 연산자'를 사용할 때 문제가 된다.

```js
var a = "hello world";
var b = 10;

switch (true) {
	case (a || b == 10):
		// 절대 여기 못 옴
		break;
	default:
		console.log( "Oops" );
}
// 웁스
```

(a || b == 10) 평가 결과는 true가 아닌 "Hello world" 이므로 매치가 되지 않는다. 이 때는 분명히 표현식의 결과가 true/false로 떨어지게 case !!(a || b == 10): (4장 강제변환 참고)과 같이 작성해야 한다.

끝은로 default 절은 선택 사항이며 (오래된 관습이긴 하지만) 꼭 끝 부분에 쓸 필요는 없다. 그런데 default에서도 break를 안써주면 그 이후로 코드가 계속 실행된다.

```js
var a = 10;

switch (a) {
	case 1:
	case 2:
		// never gets here
	default:
		console.log( "default" );
	case 3:
		console.log( "3" );
		break;
	case 4:
		console.log( "4" );
}
// default
// 3
```

default 절 실행을 하고 break가 없으니 이미 이전에 한 번 지나친 case 3: 블록을 다시 실행하게 된다.
> break가 없을 경우 다음 case를 비교하면서 실행 블록이 진행 된다고 착각하고 있었다. 예를 들어 위의 예제를 살펴보면 default 실행 후 case 3:, case 4: 로 넘어갈 때 a는 10이니까 실행이 안될거라 예상했지만 다음 break 전까지 case 표현식을 확인하지 않고 각각의 블록들이 실행된다.

이런 식의 로직이 자바스크립트에서 가능하지만 합리적이지 않고 이해하기 어렵다. 불가피하게 사용하게 된다면 자신의 의도가 명백히 드러나도록 충분히 주석을 달자.

## 5-8 정리하기

문과 표현식은 영어 언어의 문장, 어구와 각각 유사하다. 표현식은 순수하고 독립적이지만 부수 효과를 일으킬 수 있다.

자바스크립트 문법에는 순수 구문 외에 의미론적인 사용 규칙(콘텍스트)이 내재되어 있다. 예를 들어, 프로그램에서 자주 등장하는 { } 쌍은 문 블록, 객체 리터럴이 될 수도 있고, destructuring assignments(ES6), named function arguments(ES6)로 쓸 수도 있다.

자바스크립트 연산자는 그 우선순위(어떤 것이 다른 것보다 먼저 묶여지는지)와 결합성(여러 연산자 표현식이 암시적으로 그룹핑되는 방법)이 분명히 정해져 있다. 일단 우선순위/결합성 규칙을 잘 알아두기 바라며, 두 규칙이 너무 암시적이라 사용을 자제할지 아니면 짧고 깔끔한 코딩에 도움이 되니 활용할지 판단은 알아서 하자.

ASI는 자바스크립트 엔진에 내장된 '파서 에러 감지 시스템'으로 필요한 ; 이 코드에서 누락된 경우 파서 에러가 나면 자동으로 삽입해보고 코드 실행 문제가 없도록 도와준다. ASI에 대한 의견은 분분하다.

자바스크립트 에러는 몇 가지 유형이 있지만 크게 '조기 에러'(컴파일러가 던진 잡을 없는 에러)와 '런타임 에러'(try catch로 잡을 수 있는 에러)로 분류된다는 사실은 별로 잘 알려져 있지 않다. 모든 구문 에러는 프로그램을 실행 전 중단시키는 조기 에러가 분명하지만, 다른 유형의 에러들도 있다.

함수 arguments와 명명된 인자의 관계는 흥미롭다. arguments 배열은 조심하지 않으면 구멍 난 추상화에서 비롯된 갖가지 함정에 빠질 수 있다. 가급적 arguments 사용을 자제하고 사용할 경우 arguments의 원소와 이에 대응하는 명명된 인자를 동시에 사용하지 말자.

try(또는 try catch)에 붙는 finally 절에는 실행 처리 순서 면에서 별난 내용이 있다. 때로는 이런 내용이 도움이 되기도 하지만, 레이블 블록과 함께 사용하면 많은 혼란을 가중시킬 수 있다. 헷갈리는 코드를 작성하지 말고 finally로 깔끔한 코드를 작성하자.

switch는 장황한 if else 문을 대체하는 훌륭한 수단이지만, 조심해야할 특징과 꽤 그럴듯한 트릭도 함께 지니고 있다.
