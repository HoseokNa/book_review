# CHAPTER 5 문법

마지막으로 자바스크립트 언어에서 구문이 어떠헥 작동하는지(문법) 알아보자.

자바스크립트 문법은 각종 구문(연산자, 키워드)들을 서로 잘  끼워 맞춰 규칙에 맞는, 유효한 프로그램을 만들기 위한, 구조적 방법이다. 개발자들이 직접 마주할 대상은 있는 그대로의 언어 구문이지만 이 장에서는 최대한 정확한 문법을 기술하는데 초첨을 둘 것이다. 

* [5-1 문과 표현식](#5-1-문과-표현식)

## 5-1 문과 표현식

자바스크립트에서 문(Statement)과 표현식(Expression)은 아주 주용한 차이가 있으므로 명확하게 분별하자.

영어에 대입해보면 문(Statement)은 문장(Sentence), 표현식(Expression)은 어구(Phrase), 연산자는 구두점/접속사에 해당된다. 자바스크립트에서 모든 표현식은 단일한, 특정한 결괏값으로 계산된다.

```js
var a = 3 * 6;
var b = a;
b;
```

3가지 모두 표현식. 그리고 표현식이 포함된 문.

var a= 3 * 6, var b = a 두 문은 각각 변수를 선언(그리고 어떤 값으로 할당)하므로 '선언문'이라 한다.
(앞에 var가 빠진) a = 3 * 6, b = a 는 '할당 표현식'이라고 한다.

세 번째 줄 b 는 '표현식 문'이라고 일컫는다.

### 5-1-1 문의 완료 값

모든 문은 (값이 undefined라 해도) 완료 값(Completion Value)을 가진다는 사실을 의외로 모르는 사람이 많다.

문의 완료 값을 확인하는 방법은 브라우저 개발자 콘솔 창에서 문을 타이핑해보는 것이다. 콘솔 창은 가장 최근에 실행된 문의 완료 값을 기본적으로 출력하게 되어 있다.

var b = a 같은 문은 완료 값이 뭘까?

할당 표현식 b = a는 할당 이후의 값(여기서는 18)이 완료 값이지만, var 문 자체의 완료 값은 udefined다. 명세에 그렇게 적혀있기 때문이다.

완료 값을 순간 포착할 방법은 없을까? 근데 왜 꼭 그래야하는지부터 생각하자.

예를 들어, 보통의 { } 블록은 내부의 가장 마지막 문/표현식의 완료 값을 자신의 완료 값으로 반환한다.

```js
var b;

if (true) {
	b = 4 + 38;
}
```

b = 4 + 38의 완료값인 42가 반환된다.

즉, 블록의 완료 값은 내부에 있는 마지막 문의 값을 암시적으로 반환한 값이다.

하지만 다음과 같은 코드가 작동하지 않는 건 문제가 있다.

```js
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

문의 완료 값을 포착하여 다른 변수에 할당한다는 건 쉬운 구문/문법으로는 불가능하다.

*예를 들기 위함이니 아래 코드는 실제로 사용하지 말자*

유해함의 대명사 eval() 함수를 사용할 수 밖에 없다.

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

꼴보기 싫은 코드지만 잘 돌아간다!

ES7 명세에는 'do 표현식'이 제안된 상태다.

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

do { } 표현식은 (하나 이상의 문을 포함한) 블록 실행 후 블록 내 마지막 문의 완료 값을 do 표현식 전체의 완료 값으로 반환하며 결국 이 값이 변수 a에 할당된다.

아직까지는 문 완료 값을 대수롭지 않게 여기고 있지만 자바스크립트 언어가 진화할수록 그 중요성은 점점 더 부각될 것 같다.

다시 경고하지만 eval()은 사용하지 말자. 자세한 내용은 2부 스코프와 클로져를 참고하자.

### 5-1-2 표현식의 부수 효과

대부분의 표현식에는 부수 효과가 없다.

```js
var a = 2;
var b = a + 3;
```

표현식 a + 3 자체는 가령 a 값을 바꾸는 등의 부수 효과가 전혀 없다. 단지 b = a + 3 문에서 결괏값 5가 b에 할당될 뿐이다.

다음의 함수 호출 표현식은 부수 효과를 가진(가졌을지 모를) 표현식의 전형적인 예다.

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// 결괏값: `undefined`, side effect: `a` 가 변경됨.
```

다른 부수 효과를 지닌 표현식.

```js
var a = 42;
var b = a++;
```

표현식 a++이 하는 일은 두 가지다. a의 현재 값 42를 반환(그리고 b에 할당하는 것까지)하고 a 값을 1만큼 증가시킨다.

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

여기서 b 값을 43으로 착각하는 개발자들이 생각보다 많다. 부수효과가 있다는 걸 잘몰라서

```js
var a = 42;

a++;	// 42
a;		// 43

++a;	// 44
a;		// 44
```

++를 전위 연산자로 사용하면 표현식으로부터 값이 반환되기 전에 부수 효과를 일으킨다. 반면, 후위 연산자로 사용하면 값을 반환한 이후에 부수 효과가 발생한다.

NOTE: ++a++ 는 문법에 맞는 구문일까? Reference Error 발생. 부수 효과를 유발하는 연산자는 부수 효과를 일으킬 변수 레퍼런스가 꼭 필요하기 떄문이다. 우선순위 규칙에 의해 a++가 먼저 실행되어 42를 반환한다. ++ 연산자는 42 같은 원시 값에 부수 효과를 일으킬수 없으므로 ReferenceError를 던진다.

a++를 ()로 감싸면 후위 부수 효과를 캡슐화할 수 있다고 착각하는 경우도 더러 있다.

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

() 둘러싼다 해도 a++ 표현식에서 부수 효과 발생 이후 재평가된 새 표현식을 만들어내는 건 불가능하다.

하지만 문을 나열하는 콤마 연산자 , 를 사용하면 다수의 개별 표현식을 하나의 문으로 연결할 수 있다.

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

NOTE: 뒷부분에서 다시 얘기 하겠지만 ( a++ , a ) 에서 괄호를 빠뜨리면 안된다.

두번째 a 표현식을 첫 번째  a++ 표현식에서 부수 효과가 발생한 이후에 평가한다. 그래서 b 값은 43이다.

delete 역시 부수 효과를 일으키는 연산자다. delete는 객체의 프로퍼티를 없애거나 배열에서 슬롯을 제거할 때 쓴다. 하지만 단독 문으로 더 많이 쓴다.

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

delete 연산자의 결괏값은 유효한/허용된 연산일 경우 true, 그 외에는 false다. 이 연산자의 부수 효과는 바로 프로퍼티(또는 배열 슬롯)을 제거하는 것이다.

NOTE: '유효한/허용된'의 의미. 존재하지 않는 프로퍼티 또는 존재하면서 설정 가능한 프로퍼티일 경우, delete 연산자는 true를 반환. 그 외의 경우는 false를 반환.(this와 프로토타입, 비동기와 성능 참고)

마지막 예시는 = 할당 연산자.

```js
var a;

a = 42;		// 42
a;			// 42
```

42를 a에 할당하는 자체가 본질적으로 부수 효과다.

이렇게 할당 표현식/문 실행 시 할당된 값이 완료 값이 되는 작동 원리는 다음과 같은 연쇄 할당문에서 특히 유용하다.

```js
var a, b, c;

a = b = c = 42;
```

c = 42 평가 결과는 (42를 c에 할당하는 부수 효과를 일으키며) 42가 되고, b = 42 평가 결과는 (42를 b에 할당하는 부수 효과를 일으키며) 42가 된다. 결국, a = 42로 (42를 a에 할당하는 부수 효과를 일으키며) 평가 된다.

NOTE: var a= b = 42 처럼 연쇄 할당문을 잘못 쓰는 경우가 많다. 변수 b를 선언하지 않은 상태에서 실행하면 이 할당문은 b를 직접 선언하지 않는다. 대신, 엄격 모드 여부에 따라 에러가 나거나 원치 않는 전역 변수가 생성된다.

```js
function vowels(str) {
	var matches;

	if (str) {
		// 모든 모음을 추출한다.
		matches = str.match( /[aeiou]/g );

		if (matches) {
			return matches;
		}
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

잘 동작한다. 많은 개발자가 이렇게 작성한다. 할당 연산자의 부수 효과를 잘 활용하면 다음과 같이 2개의 if 문을 하나로 간단히 합칠 수 있다.

```js
function vowels(str) {
	var matches;

	// 모든 모음을 추출한다.
	if (str && (matches = str.match( /[aeiou]/g ))) {
		return matches;
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

 NOTE: matches = str.match( /[aeiou]/g) 를 감싸는 ( )를 빠뜨리면 안된다.

 두 조건이 서로 분명히 연관되어 있음을 잘 보여주기 때문에 필자는 후자를 더 선호하는 편이다. 물론 취향 차이. 
