# CHAPTER 2 값

자바스크립트에 내장된 값 타입과 작동 방식을 살펴보고 정확하게 사용할 수 있도록 이해하자.

* [2-1 배열](#2-1-배열)
* [2-2 문자열](#2-2-문자열)

## 2-1 배열

자바스크립트 배열은 문자열, 숫자, 객체 심지어 다른 배열이나(이런식으로 다차원 배열을 만든다) 어떤 타입의 값이라도 담을 수 있는 그릇이다.

```js
var a = [ 1, "2", [3] ];

a.length;		// 3
a[0] === 1;		// true
a[2][0] === 3;	// true
```

배열 크기는 미리 정하지 않고도 선언할 수 있으며 원하는 값을 추가하면 된다.

```js
var a = [ ];

a.length;	// 0

a[0] = 1;
a[1] = "2";
a[2] = [ 3 ];

a.length;	// 3
```

(빈/빠진 슬로잇 있는) '구멍 난(spare)' 배열을 다룰 때는 조심해야 한다.

```js
var a = [ ];

a[0] = 1;
// no `a[1]` slot set here
a[2] = [ 3 ];

a[1];		// undefined

a.length;	// 3
```

실행은 되지만 이런 코드에서 중간에서 건너뛴 '빈 슬롯'은 혼란을 부추길 수 있다. a[1] 슬롯 값은 응당 undefined가 될 것 같지만, 명시적으로 a[1] = undefined 세팅한 것과 똑같지는 않다.

> 차이가 궁금해서 찾아봤따. 배열에서 명시적으로 undefined로 지정했을 경우 for in, forEach 구문에서 index가 존재해서 실행된다. 하지만 건너 띈 '빈 슬롯'은 index가 없어 넘어간다. 정확한 내용과 원리는 더 찾아봐야 될 것 같다. [참고링크](https://junhobaik.github.io/js-array/)

배열 인덱스는 숫자인데, 배열 자체도 하나의 객체여서 key/property 문자열을 추가할 수 있다. 하지만 배열 length가 증가하지 않는다.

```js
var a = [ ];

a[0] = 1;
a["foobar"] = 2;

a.length;		// 1
a["foobar"];	// 2
a.foobar;		// 2
```

그런데 키로 넣은 문자열 값이 표준 10진수 숫자로 타입이 바뀌면, 마치 문자열 키가 아닌 숫자 키를 사용한 것 같은 결과가 초래된다는 점은 정말 주의해야 할 함정이다!

```js
var a = [ ];

a["13"] = 42;

a.length; // 14
```

일반적으로 배열에 문자열 타입의 key/property 를 두는 건 추천하고 싶지 않다. 그렇게 해야 한다면 객체를 다용하고 배열 원소의 인덱스는 확실히 숫자만 쓰자.

### 2-1-1 유사 배열

유사 배열 값[숫자 인덱스가 가리키는 값들의 집합]을 진짜 배열로 바꿀 때는 배열 유틸리티 함수(indexof(), concat(), forEach() 등)를 사용하여 해결하는 것이 일반적이다.
예를 들면 DOM 쿼리 작업을 수행하면 유사 배열 형태의 DOM 원소 리스트가 반환된다. 다른 예로 함수에서 arguments 객체를 사용하여 인자를 리스트로 가져오는 것(ES6부터 비 권장)도 마찬가지다.

이런 변환은 slice() 함수의 기능을 차용하는 방법을 가장 많이 쓴다.

```js
function foo() {
	var arr = Array.prototype.slice.call( arguments );
	arr.push( "bam" );
	console.log( arr );
}

foo( "bar", "baz" ); // ["bar","baz","bam"]
```

ES6부터는 기본 내장 함수 Array.from()이 이 일을 대신한다.

```js
...
var arr = Array.from( arguments );
...
```

## 2-2 문자열

자바스크립트 문자열은 실제로 생김새만 비슷할 뿐 문자 배열과 같지 않다.
문자열은 배열과 겉모습이 닮았다(유사 배열이다). 이를테면 둘 다 length 프로퍼티, indexOf() 메서드(ES5 배열에만), concat() 메서드를 가진다.

```js
var a = "foo";
var b = ["f","o","o"];

a.length; // 3
b.length; // 3

a.indexOf( "o" ); // 1
b.indexOf( "o" ); // 1

var c = a.concat( "bar" );  // "foobar"
var d = b.concat( ["b","a","r"] );  // ["f","o","o","b","a","r"]

a === c;  // false
b === d;  // false

a;  // "foo"
b;  // ["f","o","o"]
```

그렇다면 기본적으로는 둘 다 '문자의 배열'이라고 할 수 있을까? 그렇지 않다.

```js
a[1] = "O";
b[1] = "O";

a; // "foo"
b; // ["f","O","o"]
```

문자열은 불변 값(Immutable)이지만 배열은 가변 값(Mutable)이다.
a[1] 처럼 문자열의 특정 문자를 접근하는 형태가 모든 자바스크립트 엔진에서 유효한 것은 아니다. 실제로 인터넷 익스플로러 구버전은 이를 문법 에러로 인식한다(IE 7 까지 a[1] 값은 undefined로 나옴. IE8 부터 a[1]에 o가 할당됨). a.charAt(1)로 접근해야 맞다.

그리고 문자열은 불변 값이므로 문자열 메서드는 그 내용을 바로 변경하지 않고 항상 새로운 문자열을 생성한 후 반환한다. 반면에 대부분의 배열 메서드는 그 자리에서 곧바로 원소를 수정한다.

```js
c = a.toUpperCase();
a === c;	// false
a;			// "foo"
c;			// "FOO"

b.push( "!" );
b;			// ["f","O","o","!"]
```

그리고 문자열을 다룰 때 유용한 대부분의 배열 메서드는 사실상 문자열에 쓸 수 없지만, 문자열에 대해 불변 배열 메서드를 빌려 쓸 수는 있다.

```js
a.join;			// undefined
a.map;			// undefined

var c = Array.prototype.join.call( a, "-" );
var d = Array.prototype.map.call( a, function(v){
	return v.toUpperCase() + ".";
} ).join( "" );

c;				// "f-o-o"
d;				// "F.O.O."
```

다음은 문자열의 순서를 거꾸로 뒤집는 코드다. 배열에는 reverse()라는 가변 메서드가 준비되 있다. 가변 메서드기 때문에 문자열이 빌려 쓸 수 없다.

```js
a.reverse;		// undefined

b.reverse();	// ["!","o","O","f"]
b;				// ["!","o","O","f"]

Array.prototype.reverse.call( a );
// 여전히 String 객체 래퍼를 반환한다 (3장 네이티브 참고)
// for "foo" :(
```

일단 문자열을 배열로 바꾸고 원하는 작업을 수행한 후 다시 문자열로 되돌릴 것이 또 다른 꼼수(전문 용어로는 Hack이라고 함)다.

```js
var c = a
	// 'a'를 문자의 배열로 분할
	.split( "" )
	// 문자 배열의 순서를 거꾸로 뒤집는다
	.reverse()
	// 문자 배열을 합쳐 다시 문자열로 되돌린다
	.join( "" );

c; // "oof"
```

'문자열'자체에 어떤 작업을 빈번하게 수행하는 경우라면 관점을 달리하여 문자열을 문자 단위로 저장하는 배열로 취급하는 것이 더 나을 수도 있다. 배열 메서드를 사용하고 문자열로 나타내야 할 때는 언제나 문자 배열에 join("") 메서드를 호출하면 된다.
