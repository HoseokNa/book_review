# CHAPTER 4 강제변환

이 장의 목적은 강제변환의 좋고 나쁨을 충분히 이해하고 자신이 프로그램에 적절한지 스스로 판달할 수 있는 역량을 늘리기다.

* [4-1 값 변환](#4-1-값-변환)
* [4-2 추상 연산](#4-2-추상-연산)
* [4-3 명시적 강제변환](#4-3-명시적-강제변환)
* [4-4 암시적 변환](#4-4-암시적-변환)
* [4-5 느슨한/엄격한 동등 비교](#4-5-느슨한/엄격한-동등-비교)

## 4-1 값 변환

어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 '타입 캐스팅(Type Casting)', (값이 사용되는 규칙에 따라) 암시적이면 '강제변환(Coercion)'이라고 한다.

자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컫는 경향이 많다. 여기서는 '암시적 강제변환(Explicit Coercion')'과 '명시적 강제변환(Implicit Coercion)' 두 가지로 구별하겠다.

* 명시적 강제변환 : 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백
* 암시적 강제변환 : 다른 작업 도중 불분명한 부수 효과로부터 발생하는 타입변환

```js
var a = 42;

var b = a + "";			// 암시적 강제변환

var c = String( a );	// 명시적 강제변환
```

두 가지 접근 방식 모두 42를 "42"로 바꾸는데, 여기서 논란의 핵심은 변환을 '어떻게' 할 것이냐 하는 문제다.

## 4-2 추상 연산

어떻게 값이 문자열, 숫자, 불리언 등의 타입이 되는지, 그 기본 규칙을 알아보자.

### 4-2-1 ToString

'문자열이 아닌 값 -> 문자열' 변환 작업은 ES5 9.8의 ToString 추상 연산 로직이 담당한다. 내장 원시 값은 본연의 문자열화 방법이 정해져 있다.(null -> "null", undeinfed -> "undefined", true -> "true") 숫자는 그냥 문자열로 바뀌고 너무 작거나 큰 값은 지수 형태로 바뀐다.(2장 값 참고).

```js
// `1.07` 에 `1000`을 7번 곱한다
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// 소수점 이하로 3 x 7 => 21자리까지 내려간다
a.toString(); // "1.07e21"
```

일반 객체는 특별히 지정하지 않으면 기본적으로 (Object.prototype.toString()에 있는) toString() 메서드가 내부 [[Class]]를 반환한다.(예: "[object Object]") 자신의 toString() 메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 호출된다.

배열은 기본적으로 재정의된 toString()이 있다. 문자열 변환 시 모든 원소 값이 (각각 문자열로 바뀌어) 콤마로 분리된 형태로 이어진다.

```js
var a = [1,2,3];
a.toString(); // "1,2,3"
```

또한 toString() 메서드는 명시적으로도 호출 가능하며, 문자열 콘텍스트에서 문자열 아닌 값이 있을 경우에도 자동 호출된다.

#### JSON 문자열화

JSON 문자열화는 강제변환과 똑같지는 않지만, 방금 전 살편본 ToString 규칙과 관련이 있다.

대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는, JSON 문자열화나 toString() 변환이나 기본적으로 같은 로직이다.

```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (따옴표가 붙은 문자열 인자를 문자열화한다)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

JSON 안전 값(JSON-Safe Value)은 모두 JSON.stringfy()로 문자열화할 수 있다. (아닌 예: undefined, 함수, Symbol, 환형 참조 객체)

JSON.stringfy() 인자가 undefined, 함수, 심벌 값이면 자동으로 누락시키며 이런 값들이 만약 배열에 포함되어 있으면 (배열 인덱스 정보가 뒤바뀌지 않도록) null로 바꾼다. 객체 프로퍼티에 있으면 간단히 지운다.

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}
```

혹시라도 JSON.stringfy()에 환형 참조 객체를 넘기면 에러가 난다.

객체 자체에 toJSON() 메서드가 정의되어 있다면, 먼저 이 메서드를 호출하여 직렬화한 값을 변환한다.

부적절한 JSON 값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 toJSON() 메서드(해당 객체의 JSON 안전 버전을 반환)를 따로 정의해야 한다.

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// `a`를 환형 참조 객체로 만든다
o.e = a;

// 환형 참조 객체는 JSON 문자열화 시 에러가 난다
// JSON.stringify( a );

// JSON 값으로 직렬화하는 함수를 따로 정의한다
a.toJSON = function() {
	// 직렬화에 프로퍼티 'b'만 포함시킨다.
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

toJSON()은 (어떤 타입이든) 적절히 평범한 실제 값을 반환하고 문자열화 처리는 JSON.stringfy()이 담당한다. 다시 말해 toJSON()의 역할은 '문자열화하기 적당한 JSON 안전 값으로 바꾸는 것'이지, 'JSON 문자열로 바꾸는 것'이 아니다.

```js
var a = {
	val: [1,2,3],

	// 맞다!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// 틀리다!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]"
```

b는 배열 자체가 아니라 반환된 문자열을 다시 문자열화한다.

배열 아니면 함수 형태의 대체자(Replace)를 JSON.stringfy()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 (포함할 프로퍼티와 제외할 프로퍼티를 결정하는) 필터링 하는 방법이 있다. toJSON()이 직렬화할 값을 준비하는 방식과 비슷하다.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

JSON.stringfy()는 세 번째 선택 인자는 스페이스라고 하며 사람이 읽기 쉽도록 들여쓰기를 할 수 있다.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

JSON.stringfy()는 직접적인 강제변환의 형식은 아니지만 두 가지 이유로 ToString 강제 변환과 연관된다.
1. 문자열, 숫자, 불리언, null 값이 JSON으로 문자열화하는 방식은 ToString 추상 연산의 규칙에 따라 문자열 값으로 강제변환되는 방식과 동일하다.
2. JSON.stringfy()에 전달한 객체가 자체 toJSON() 메서드를 갖고 있다면, 문자열화 전 toJSON()이 자동 호출되어 JSON 안전 값으로 '강제변환' 된다. 

### 4-2-2 ToNumber

'숫자 아닌 값 -> 수식 연산이 가능한 숫자' 변환 로직은 ES5 9.3 ToNumber 추상 연산에 잘 정의되어 있다.

ex) true => 1, false => 0, undefined => NaN, (희한하게도) null => 0

문자열 값에 ToNumber를 적용하면 대부분 숫자 리터럴 규칙/구문과 비슷하게 작동한다. 변환이 실패하면 (숫자 리터럴 구문 에러가 아닌) 결과는 NaN이다. 한가지 다른 점은 0이 앞에 붙은 8진수는 ToNumber에서 올바른 숫자 리터럴이라도 8진수로 처리하지 않는다.(일반 10진수로 처리)

객체(그리고 배열)는 일단 동등한 원시 값으로 변환 후 그 결괏값(아직 숫자가 아닌 원시 값)을 ToNumber 규칙에 의해 강제 변환한다.

동등한 원시 값으로 바꾸기 위해 ToPrimitive 추상 연산 과정에서 해당 객체가 valueOf() 메서드를 구현했는지 확인한다. ValueOf()를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환 한다. 그렇지 않을 경우 toString() 메서드가 존재하면 toString()을 이용하여 강제변환 한다.

어찌해도 원시 값으로 바꿀 수 없을 땐 TypeError 오류를 던진다.

ES5 부터는 [[Prototype]]이 null인 경우 대부분 Object.create(null)를 이용하여 강제변환이 불가능한 객체(valueOf(), toString()이 없는 객체)를 생성할 수 있다.

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### 4-2-3 ToBoolean

자바스크립트에는 true와 false라는 키워드가 존재한다. 그리고 1을 true로, 0을 false로 (역방향도 마찬가지) 강제변환할 수는 있지만 그렇다고 두 값이 똑같은 건 아니다.

#### Falsy 값

true/false가 아닌 값을 boolean에 상당한 값으로 강제 변환하면 어떻게 작동할까?

다음 둘 중 하나다.
1. boolean으로 강제변환하면 false가 되는 값
2. 1번을 제외한 나머지(즉 명백히 true인 값)

명세가 정의한 'falsy' 값은 다음과 같다.
* undefined
* null
* false
* +0, -0, NaN
* ""

이게 전부다. 이 'falsy' 값을 boolean으로 강제변환하면 false다.

'truthy' 값 목록은 없지만 'falsy' 값 목록에 없으면 응당 'truthy' 값이 된다. (모든 객체도)

| 인자타입 | 결괏값 |
| --- | --- |
| `Undefined` | false |
| `Null` | false |
| `Boolean` | 인자 값과 동일(변환 안함) |
| `Number` | +0, -0, NaN이면 false, 그 외에는 true |
| `String` | 인자가 공백 문자열(length가 0)이면 false, 그 외에는 true |
| `Object` | true |

#### Falsy 객체

뭔 소리? falsy 값을 둘런싼 객체 래퍼 얘기임?

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );

var d = Boolean( a && b && c );

d; // true
```

a, b, c는 명백히 falsy 값을 감싼 객체다. 하지만 모두 true임을 알 수 있다.

그럼 얘 뭐임?

사실 이 객체는 순수 자바스크립트의 일부가 아니다.

일반적인 자바스크립트의 의미(Semantics) 뿐만 아니라 브라우저만의 특이한 작동 방식을 가진 값을 생성하는 경우가 있는데, 이거싱 바로 'falsy 객체'의 정체다.

'falsy 객체'를 boolean으로 강제변환하면 false다.

why?

가장 유명한 사례

개발자들이 (자바스크립트 엔진이 아닌) DOM에서 사용했던 유사 배열(객체), document.all이다. document.all은 웹 페이지의 요소를 자바스크립트 프로그램에서 가져올 수 있게 해주었고, 그래서 실제로 'truthy'한 일반 객체처럼 작동했다. 하지만 이젠 더 이상 아니다.

document.all은 '비표준'이며, 이미 오래전에 비 권장/폐기되었다.

그냥 날릴수는 없나? 그러기에는 document.all에 의존하는 레거시 코드 베이스가 너무 많았다. (오래된 비표준 IE 부라우저를 감지하는 수단으로 줄곧 사용해옴)

그래서 document.all이 falsy인 것처럼 돌아가게 꼼수 고고씽

결국 브라우저 때문에 말도 안되는 비표준('falsy 객체')이 자바스크립트에 더해진 것이다 ㅠㅠ

#### truthy 값

falsy 값 목록에 없으면 무조건 truthy 값

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

정답은 true. 문자열 값 자체는 모두 truthy.(유일한 falsy 값 문자열은 " "다)

```js
var a = [];				// 빈 배열 -- truthy or falsy?
var b = {};				// 빈 객체 -- truthy or falsy?
var c = function(){};	// 빈 함수 -- truthy or falsy?

var d = Boolean( a && b && c );

d;
```

모두 truthy. (falsy 값 목록에 없기 떄문)

truthy 값은 짱 많음. 그러니 그냥 falsy 값 목록을 외워라!

## 4-3 명시적 강제변환

명시적 강제변환(Explicit Coercion)은 분명하고 확실한 타입변환이다. 개발자들이 흔히 사용하는 타입변환은 대개 이 명시적 강제변환 범주에 속한다.

명시적 강제변환은 정적 타입 언어에서 지극히 당연하다고 여겨지는 타입변환의 관례를 충실히 따르고 있기에 별다른 논쟁거리는 없다. 그러니 당연하게 받아들이자.

### 4-3-1 명시적 강제변환: 문자열 -> 숫자

'문자열<->숫자' 강제변환은 String()과 Number() 함수를 이용하는데, 앞에 new 키워드가 붙지 않기 때문에 *객체 래퍼를 생성하는 것이 아니다*.

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

각각 ToString, ToNumber 추상 연산 로직에 의해 숫자 값으로 강제변환한다.

누가 봐도 결과적으로 타입변환이 일어난다는 사실은 의심할 여지가 없으므로 '명시적 강제변환'이 맞다.

사실 이러한 사용법은 다른 정적 타입 언어와 비슷하다.(ex C/C++ (int)x, int(x))

String()과 Number() 이외에도 '문자열<->숫자'의 '명시적인' 타입변환 방법은 또 있다.

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

a.toString() 호출은 겉보기엔 명시적이지만, 몇 가지 암시적인 요소가 감춰져 있다. 원시 값 42에는 toString() 메서드가 없으므로 엔진은 toString()을 사용할 수 있게 자동으로 42를 객체 래퍼로 '박싱'한다. 말하자면 '명시적으로 아시적인' 작동이다.

+c의 +는 단항 연산자다. 덧셈이 아니라 피연산자 c를 숫자로, 명시적 강제변환한다. (오픈 소스 자바스크립트 커뮤니티에서는 + 단항 연산자를 명시적 강제변환 형식으로 대부분 인정하는 분위기다.)

설사 +c처럼 쓰는 걸 좋아하는 사람이라도 헷갈리는 경우가 있다.

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

- 단항 연산자 역시 +처럼 강제변환을 하지만 부호를 뒤바꿀 수 있다. 그렇다고 --로 하면 증감연산자가 되니 공란을 넣어주자. - -"3.14 => 3.14로 강제 변환

이런 식으로 단항 연산자 뒤에 이진 연산자를 붙이면 헬이 될 수 있다.

```js
1 + - + + + - + 1;	// 2
```

가급적 +/- 단항 연산자를 다른 연산자와 인접하여 사용하지 말자. d = +c (또는 d =+ c)는 d에 c를 더하는 d += c 와 완전히 다른 코드.

명시적으로 변환하여 문제를 악화시키지 말고 혼동을 줄이는게 좋다!

#### 날짜 -> 숫자

+ 단항 연산자는 'Date 객체 -> 숫자' 강제변환 용도로도 쓰인다. 결괏값이 날짜/시각 값을 유닉스 타임스탬프 표현형이기 때문이다.

```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```

다음과 같이 현재 시각을 타임스탬프로 바꾸는 관용적인 방법.

```js
var timestamp = +new Date();
```

강제변환을 하지 않고 Date 객체로부터 타임스탬프를 얻는 방법이 있는데 강제변환 보다 더 명시적이다.

```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

하지만 ES5에 추가된 정적 함수 Date.now()를 쓰는게 더 낫다.

```js
var timestamp = Date.now();
```

폴리필

```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

날짜 타입에는 강제변환 비추. 현재 타임스탬프는 Date.now(), 그 외 특정 날짜/시간의 것은 new Date().getTime()을 쓰자.

#### 이상한 나라의 틸드(~)

비트 연산을 하면 피연산자는 32비트 값으로 강제로 맞춰지는데, ToInt32 추상 연산이 이 역할을 맡는다.

우선 ToInt32는 ToNumber 강제변환 한다. "123"이라면 ToInt32 규칙을 적용하기 전 123으로 바꾼다.

엄밀히 말해 이 자체는 (타입이 바뀐 것은 아니므로!) 강제변환이 아니지만, 숫자 값에 | 나 ~ 비트 연산자를 적용하면 전혀 다른 숫자 값을 생성하는 강제변환 효과가 있다.

0 | x 의 'OR' 연산자(|)는 사실상 ToInt32 변환만 수행한다.

```js
0 | -0;			// 0
0 | NaN;		// 0
0 | Infinity;	// 0
0 | -Infinity;	// 0
```

이러한 특수 숫자들은(64비트 IEEE 754 표준) 32비트로 나타내는 것이 불가능하므로 ToInt32 연산 결과는 0 이다.

0 | __ 변환은 명세서 관점에서 보면 명시적이지만 비트 연산을 이해하지 못하는 사람에게는 암시적인 마법으로 보일 수 있다. 여기서는 다른절과 설명을 위해 명시적으로 하겠다.

~ 연산자는 먼저 32비트 숫자로 '강제변환'한 후 NOT 연산을 한다(각 비트를 거꾸로!)

~는 2의 보수를 구한다. ~x는 대략 -(x + 1)과 같다.

```js
~42;	// -(42+1) ==> -43
```

-(x + 1)의 결과가 0으로 만드는 유일한 값은 -1이다. 일정 범위 내의 숫자 값에 ~ 연산을 할 경우 입력 값이 -1이면 (false로 쉽게 강제변환할 수 있는) falsy한 0, 그 외엔 truthy한 숫자 값이 산출된다.
> Number의 falsy 목록은 +0, -0, NaN 3가지!. 뒤에 나오는 ~a.indexof( "lo" ) 값이 -4가 되는데 -4는 falsy 목록에 없으므로 true가 된다. 헷갈리는 부분이 있어 적어 놓는다.

여기서 -1과 같은 성질의 값을 흔히 '경계 값(Sentinel Value)'이라고 일컫는다. 예를 들어 C 언어의 함수는 대게 -1을 경계 값으로 사용.(return >= 0는 '성공', return -1 은 '실패')

마찬가지로 자바스크립트 문자열 메서드 indexOf()는 특정 문자를 검색하고 발견하면 0부터 시작하는 숫자 값(index)을, 발견하지 못했을 경우 -1을 반환한다.(사실 어떤 하위 문자열이 다른 문자열에 포함되어 있는지 조사하는 용도로 더 많이 사용)

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// found it!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// found it
}

if (a.indexOf( "ol" ) < 0) {	// true
	// not found!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// not found!
}
```

>= 0 이나 == -1 같은 코드는 좀 지전분해 보임. 이런 부류의 코드는 '구멍 난 추상화(Leacky Abstraction)', 즉 (경계 값 -1을 '실패'로 정해버린) 내부 구현 방식을 내가 짠 코드에 심어놓은 꼴이다. 이런 부분은 감추는게 더 낫다고 생각한다.

그러니까 indexOf()에 ~를 붙이면 어떤 값을 '강제변환'(실제로는 단순히 변형)하여 Boolean 값으로 적절하게 만들 수 있다.

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- truthy!

if (~a.indexOf( "lo" )) {	// true
	// 찾았다!
}

~a.indexOf( "ol" );			// 0    <-- falsy!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// 못 찾았다!
}
```

~은 indexOf()로 검색 결과 '실패'시 -1을 falsy한 0으로, 그 외에는 truthy한 값으로 바꾼다.

Note : -(x+1)은 ~의 의사 알고리즘으로, 내부적으로 ~-1을 -0으로 만들지만, 수학 연산이( 아닌 비트 연산이므로 결괏값은 0이 된다.

#### 비트 잘라내기

숫자의 소수점 이상 부분을 잘라내기(truncate) 위해 (즉, 완전수로 '강제변환'하려고) 더블 틸드 ~~를 사용하는 개발자들이 있다. 흔히들 이렇게 하면 Math.floor()와 같은 결과가 나온다고 생각한다.

~~가 하는 일은 이렇다. 먼저 맨 앞의 ~는 ToInt32 '강제변환'을 적용한 후 각 비트를 거꾸로 한다. 그리고 두 번째 ~는 비트를 또 한 번 뒤집는데, 결과적으로 원래 상태로 되돌린다. 결국 ToInt32 '강제변환'(잘라내기)만 하는 셈이다.

그러나 ~~ 사용 시 유의할 점이 있다. 우선 ~~ 연산은 32비트 값에 한하여 안전하다. 그런데 그보다도 *음수에서는 Math.floor()와 결괏값이 다르다는 사실*을 조심하자!

```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

~~x는 (32비트) 정수로 상위 비트를 잘라낸다. 하지만 같은 일을 하는 x | 0 가 (조금이더라도) 더 빠를 것 같은데??

하지만 연산자 우선순위(5장 문법 참고)를 생각해서 x | 0 대신 ~~x를 사용하자.

```js
~~1E20 / 10;		// 166199296

1E20 | 0 / 10;		// 1661992960
(1E20 | 0) / 10;	// 166199296
```

이전에 제시한 다른 조언들과 마찬가지로 주변 동료 개발자들이 이해하고 있다는 전제하에 ~와 ~~를 명시적인 '강제변환' 및 값 변형 장치로 잘 활용하자.

## 4-4 암시적 변환

암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 코드를 잡동사니로 가득 채워버리는 장황함, 보일러플레이트, 불필요한 상세 구현을 줄이는 것이다.

### 4-4-1 '암시적'이란?

```js
SomeType x = SomeType( AnotherType( y ) )

SomeType x = SomeType( y )
```

엄격한 타입언어의 의사코드를 가정했을 때 위의 2가지 코드 중 아래와 같이 쓰면 타입변환을 단순화 할 수 있다. 단순화시킨 타입변환 코드가 실제로 코드 가독성을 높이고 세세한 구현부를 추상화하거나 감추는데 도움이 된다고 생각한다.

완벽한 비유는 아니지만 핵심은 자바스크립트의 암시적 강제변환 역시 같은 이치로 우리가 작성하는 코딩에 도움이 될 수 있다는 것이다.

암시적 강제변환의 '나쁜 단면'을 보고 나서 전체가 다 나쁘다고 단정하지 말자. 부디 객관적으로 암시적 강제변환을 바라보고 수용하자.

### 4-4-2 암시적 강제변환: 문자열 <-> 숫자

+연산자는 '숫자의 덧셈, 문자열 접합' 두 가지 목적으로 오버로드 된다. 자바스크립트 엔진은 어떻게 판단할까?

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

피연산자가 한쪽 또는 양쪽 모두 문자열인지 아닌지에 따라 +연산자가 문자열 붙이기를 할지 결정한다고 보통 잘못 알고 있는 경우가 많다. 부분적으로 맞지만 더 복잡하다.

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

a,b 모두 문자열이 아니지만 분명히 둘 다 문자열로 강제변환된 후 접합됐다.

+알고리즘(피연산자가 객체 값일 경우)은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.

ToPrimitive 추상 연산 -> number 콘텍스트 힌트를 넘겨 [[DefaultValue]] 알고리즘을 호출

정리하면 + 연산의 한쪽 피연산자가 문자열이면(또는 처리를 통해 문자열이 되면) +는 문자열 붙이기 연산을 한다. 그 밖에는 언제나 숫자 덧셈을 한다.

NOTE : 잘 알려진 강제변환 함정. [] + {} => "[object Object]" , {} + [] => 0

근데 이게 암시적 강제변환과 무슨 상관?

숫자는 공백 문자열 ""과 더하면 간단히 문자열로 강제변환된다.

```js
var a = 42;
var b = a + "";

b; // "42"
```

a + ""는 숫자를 문자열로 (암시적) 강제변환하는 아주 흔한 관용 코드다.

ToPrimitive 연산 과정에서 a + ""는 a 값을 valueOf() 메서드에 전달하여 호출하고, 그 결괏값은 ToString 추상 연산을 하여 최종적인 문자열로 변환된다. 그러나 String(a)는 toString()을 직접 호출할 뿐이다.

두 방법 모두 문자열을 반환하지만 원시 숫자 값이 아닌 객체라면 결과가 달라질 수 있다.

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

대부분 상관 없지만 valueOf(), toString() 메서드를 직접 구현한 객체가 있으면 조심하자.

방향을 바꾸어 '문자열->숫자' 암시적인 강제변환을 알아보자.

```js
var a = "3.14";
var b = a - 0;

b; // 3.14
```

-연산자는 숫자 뺼셈 기능이 전부이므로 a - 0 은 a 값을 강제변환한다. ( a * 1 , a / 1 도 마찬가지)

객체 값에 - 연산을 하면? 이전의 +와 비슷하다.

```js
var a = [3];
var b = [1];

a - b; // 2
```

문자열로 강제변환(toString()로 직렬화) 숫자로 강제변환된다. 그리고 마지막엔 - 연산을 한다.

b = String(a)(명시적)과 b = a + ""(암시적)을 비교하자. 둘 다 경우에 따라 유용하게 코드에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이쓴다. 암시적 강제변환 낫 배드요.

### 4-4-2 암시적 강제변환: boolean <-> 숫자

암시적 강제변환의 효용성은 복잡한 형태의 불리언 로직을 단순한 숫자 덧셈 형태로 단순화할 때 빛을 발한다. 범용적인 기법은 아니지만 특정 상황에선 기발한 해법이 될 수 있다.

```js
function onlyOne(a,b,c) {
	return !!((a && !b && !c) ||
		(!a && b && !c) || (!a && !b && c));
}

var a = true;
var b = false;

onlyOne( a, b, b );	// true
onlyOne( b, a, b );	// true

onlyOne( a, b, a );	// false
```

onlyOne()은 세 인자 중 정확히 하나만 true/truthy인지 아닌지를 확인하는 함수다. 하지만 이런 식으로 여러개의 인자를 처리해야 할 경우 구현하기 어려워 진다.

그런데 boolean 값을 숫자(명시적으로 0 또는 1)로 변환하면 의외로 문제가 쉽게 풀린다.

```js
function onlyOne() {
	var sum = 0;
  // for 루프 대신 ES5 reduce() 유틸리티를 써도 된다.
	for (var i=0; i < arguments.length; i++) {
		// falsy 값 skip
		// 0으로 취급하는 셈, 하지만NaN은 피해야 한다.
		if (arguments[i]) {
			sum += arguments[i];
		}
	}
	return sum == 1;
}

var a = true;
var b = false;

onlyOne( b, a );		// true
onlyOne( b, a, b, b, b );	// true

onlyOne( b, b );		// false
onlyOne( b, a, b, b, b, a );	// false
```

true/truethy를 숫자로 강제변환하면 1이므로 그냥 숫자를 모두 더한 것이 전부이고, sum += arguments[i]에서 암시적 강제변환이 일어난다.

다음은 이 코드의 명시적 강제변환 버전인다.

```js
function onlyOne() {
	var sum = 0;
	for (var i=0; i < arguments.length; i++) {
		sum += Number( !!arguments[i] );
	}
	return sum === 1;
}
```

먼저 !!arguments[i]로 인자 값을 true/false로 강제변환한다. 따라서 onlyOne("42", 0) 처럼 비 boolean 값을 넘긴다 해도 문제 없다.(안 그랬다면 문자열을 붙이기를 했을 것)

!!arguments[i]는 불리언 값이 확실하므로 Number()로 한 번 더 강제변환하여 0 또는 1로 바꾼다.

그럼 뭐가 더 나은 방법일까?

작가는 암시적 강제변환 코드가 더 우하한 것 같다. 후자는 조금 쓸데없이 장황한 느낌이 든다.

판단은 여러분의 몫!

#### 4-4-4 암시적 강제변환: * -> boolean

가장 평범하면서도 가장 골칫거리다.

암시적 강제변환은 어떤 값이 강제로 바뀌어야 하는 방향으로 사용할 때 발생한다는 것을 기억하자. 숫자, 문자열 연산에서 일어나는 강제변환은 쉽게 알아챌 수 있다.

다음은 boolean으로 (암시적인) 강제변환이 일어나는 표현식을 열거한 것이다.

1. if () 문의 조건 표현식
2. for ( ; ; )에서 두 번째 조건 표현식
3. while () 및 do while() 루프의 조건 표현식
4. ? : 삼항 연산 시 첫 번째 조건 표현식
5. ||(논리OR) 및 &&(논리AND)의 좌측 피연산자(테스트 표현식 역할을 한다 - 곧 설명한다!)

이런 콘텍스트에서 boolean 아닌 값이 사용되면, ToBoolean 추상 연산 규칙에 따라 일단 boolean 값으로 암시적 강제변환된다.

```js
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
	console.log( "넵" );		// 넵
}

while (c) {
	console.log( "놉, 절대 실행 안되지" );
}

c = d ? a : b;
c;					// "abc"

if ((a && d) || c) {
	console.log( "넵" );		// yep
}
```

예제의 모든 콘텍스트에서 그와 동등한 boolean 값으로 강제변환된다.

### 4-4-5 &&와 || 연산자

|| 및 && 연산자는 아주 중요하면서도 미묘한 차이가 있다.

솔직히 이것들을 '논리 연산자'라고 부르는 건 명칭만으론 이 연산자들의 기능을 나타내기에 한참 부족하기 때문에 부적절하다고 본다. 내가 작명하면 '선택 연산자' 또는 '피연산자 선택 연산자' 정도로 할 것이다.

이유는 자바스크립트에서 이 두 연산자는 다른 언어와 달리 실제로 결괏값이 논리 값(boolean)이 아니기 때문이다.

ES5 11.11에 명세
* && 또는 || 연산자의 결괏값이 반드시 boolean 타입이어야 하는 것은 아니며 항상 두 피연산자 표현식 중 어느 한쪽 값으로 귀결 된다.

```js
var a = 42;
var b = "abc";
var c = null;

a || b;		// 42
a && b;		// "abc"

c || b;		// "abc"
c && b;		// null
```

다른 언어라면 결괏값은 당연히 true, false다. 그런제 자바스크립트에서는(파이썬, 루비도) 결괏값이 피연산자 값이다.

||,&& 연산자는 우선 첫 번째 피연산자(a, c)의 boolean 값을 평가한다. 비 boolean 타입이면 먼저 ToBoolean으로 강제변환 후 평가를 계속한다.

|| 연산자는 그 결과(첫 번째 피연산자)가 true면 첫 번째 피연산자(a, c) 값을, false이면 두 번째 피연산자(b) 값을 반환.

&& 연산자는 그 결과(첫 번째 피연산자)가 true면 두 번째 피연산자(b) 값을, false이면 첫 번째 피연ㅅ나자(a, c) 값을 반환.

c && b 에서 c는 null이므로 falsy 값이다. 하지만 && 표현식은 평가 결과인 false(falsy를 강제변환)가 아니라 c 자신의 값, null로 귀결된다.

```js
a || b;
// 대략 다음과 같다:
a ? a : b;

a && b;
// 대략 다음과 같다:
a ? b : a;
```

NOTE : a ? a : b 의 a가 만약 복잡한 표현식(함수 호출 등의 부수 효과를 가진 표현식)이라면, a 표현식은 (처음 평가 결곽가 truthy라면) 두 번 평가될 가능성이 있다. 반면, a || b에서는 a는 단 한번만 평가하고 그 결과는 테스트 수행시 강제변환과 최종 결괏값(해당 시) 양쪽 모두 사용된다. a && b와 a ? b : a 도 마찬가지.

다음은 이런 특성을 무지 잘 활용한 예시.

```js
function foo(a,b) {
	a = a || "hello";
	b = b || "world";

	console.log( a + " " + b );
}

foo();					// "hello world"
foo( "오 마이", "갓!" );	// "오 마이 갓!"
```

a = a || "hello!" 같은 패턴의 관용 코드는 a 값이 없으면(아니면 a가 falsy면) "hello!"를 a에 할당한다.

하지만 조심하자!

```js
foo( "그래 됐어!", "" ); // "그래 됐어! world" <-- 웁스!
```

두 번째 인자 " "는 falsy 값이므로 "word"가 할당된다. 프로그래머의 의도는 b를 ""로 만들려는 것이었겠지만.

그러므로 이런 패턴은 falsy 값을 무조건 건너띌 경우에만 사용하도록하자. 그렇지 않으면 삼항 연산자로 더욱 명시적으로 지정하자.

디폴트 값을 할당하는 관용 코드는 너무 일반적(그리고 유용하다!)이다.

그러면 &&는?

자바스크립트 압축기(Minifier)에서 더 많이 쓰는, 또 다른 관용 코드가 있다. && 연산자는 첫 번째 피연산자의 평가 결과가 truthy일 때에만 두 번째 피연산자를 '선택'한다고 했는데 이런 특성을 '가드 연산자(Guard Operator)'라고 한다. 첫 번째 표현식이 두 번째 표현식의 '가드' 역할을 하는 것이다.

```js
function foo() {
	console.log( a );
}

var a = 42;

a && foo(); // 42
```

a 평가 결과가 truthy일 때에만 foo ()가 호출된다. 평가 결과가 falsy면 a && foo() 표현식은 그 자리에서 조용히 실행을 멈추고 (그래서 '단락 평가(Short Circuiting)'라고 한다) foo()는 호출되지 않는다.

대부분은 if (a) { foo(); } 처럼 작성한다. 하지만 JS 압축기는 코드를 최대한 쥐어짜야 하므로 a && foo() 같이 처리한다. 그러니 이런 코드를 해독할 일이 있으면 그 의미와 이유를 알고 있자.

||, && 연산 결과가 실제로 true/false가 아니라는 사실이 여러분에 불편할 수도 있다. 그럼 지금까지의 코드는 왜 정상 동작하나? 걱정마슈!

```js
var a = 42;
var b = null;
var c = "foo";

if (a && (b || c)) {
	console.log( "넵" );
}
```

이 코드는 짐작한대로 동작한다. a && (b || c) 표현식의 실제 결과는 "foo"다. if 문은 이 "foo"를 boolean 타입으로 강제변환하여 true로 만든다.

여러분이 작성해온 코드는 안전하다. 내면의 진실에 눈을 뜨게 되었을 뿐. 뿌듯쓰.

그래도 아직도 '(암시적) 강제변환 사용 금지 클럽'의 열성 회원이라면, 다음과 같은 코드를 작성해야 칭찬하겠쥬?

```js
if (!!a && (!!b || !!c)) {
	console.log( "넵" );
}
```

### 4-4-6 심벌의 강제변환

지금까지 다룬 명시적/암시적 강제변환은 코드 가독성이 문제일 뿐 가시적인 결과의 차이는 거의 없었다.

그러나 Symbol 탓에 강제변환 체계에 조심해야할 함정이 하나 더 늘었다. 'Symbol -> 문자열' 명시적 강제변환은 허용되나 암시적 강제변환은 금지되며 시도만 해도 에러가 난다.

```js
var s1 = Symbol( "cool" );
String( s1 );					// "Symbol(cool)"

var s2 = Symbol( "not cool" );
s2 + "";						// TypeError
```

Symbol 값은 절대 숫자로 변환되지 않지만(양방향 모두 에러), 희한하게도 boolean 값으로는 명시적/암시적 모두 강제변환(항상 true)이 가능하다.

Symbol 값을 다루거나 강제변환할 떄에는 유의하자. 하지만 원래 만들어진 의도대로만 사용한다면(3장 네이티브 참고) 강제변환할 필요는 거의 없을 것이다.

## 4-5 느슨한/엄격한 동등 비교

느슨한 동등 비교(Loose Equals)는 == 연산자를, 엄격한 동등 비교(Strict Equals)는 === 연산자를 각각 사용한다. 두 연산자 모두 두 값의 '동등함(Equality)'을 비교하지만 '느슨함'과 '엄격함'이라는 아주 중요한 차이점 있고 특히 '동등함'의 판단 기준이 다르다.

많은 이들이 종종 "==는 값의 동등함을, ===는 값과 타입 모두의 동등함을 비교한다"라고 오해한다. 그럴듯하지만 정확하지 않다.

정확한 정의. *"동등함의 비교 시 ==는 강제변환을 허용하지만, ===는 강제변환을 허용하지 않는다."*

### 4-5-1 비교 성능

전자의 (부정확한) 정의와 후자의 (정확한) 정의를 잠시 음미해보자.

전자에 의하면 ===는 타입까지 체크하므로 ==에 비해 할 일이 많다. 후자에 따르면 오히려 타입이 다르 ㄹ경우 강제변환을 해야 하므로 ==가 더 할 일이 많다.

하지만 == 이 === 보다 눈에 띄기 처리가 더뎌서 어떤 식으로든 성능에 영향을 미치는 것처럼 생각하진 말자. 강제변환 시 처리 시간이 약간 더 소요되지만 불과 몇 마이크로 초 단위의 차이일 뿐이다.

타입이 같은 두 값의 동등비교라면, 알고리즘은 동일하다. 엔진의 내부 구현 방식으 조금씩 다를 수 있지만, 기본적으로 하는 일은 같다.

타입이 다른 두 값의 동등 비교에서 성능은 중요한 포인트가 아니다. 자문해봐야할 사항은 비교 과정에서 강제변환의 개입여부다.

*강제변환이 필요하다면 느슨한 동등 연사자(==)를, 필요하지 않다면 엄격한 동등 연산자(===)를 사용하자.*

NOTE : 어차피 == 든, === 든 피연산자의 타입을 체크하는 건 매한가지다. 다른 점은 타입이 다를 때 이후 처리 로직이다.

### 4-5-2 추상 동등 비교

== 연산자 로직은 ES5 11.9.3 '추상적 동등 비교 알고리즘'에 상술되어 있다. 모든 가능한 타입별 조합마다 (필요시) 강제변환을 어떻게 수행하는지 그 방법이 적혀 있다.

NOTE : (암시적) 강제변환을 곱지 않게 보는 사람들이 가장 일반적으로 비난하는 대상이 바로 이 '추상적 동등' 관련 규칙이다. 너무 난해하며 직관적이지 못해 코드의 가독성을 향상하지는 못할망정 버그만 양산하는 규칙들이라고 주장한다. 하지만 실제로 '추상적 동등' 규칙은 쉬운 용어로 평이하게 기술되어 있다. 의심나면 매 말을 믿고 ES5 11.9.3을 직접 읽어보자.

첫번 째 항(11.9.3.1). 비교할 두 값이 같은 타입이면 누구나 예상하듯이 값을 식별하여 간단히, 자연스럽게 견주어본다. (42와 동등한 값은 42뿐, "abc"와 동등한 값은 "abc")

다음 예외는 사소하지만 상식을 벗어남으로 주의하자.

* NaN은 그 자신과도 결코 동등하지 않다.(2장 값 참고)
* +0과 -0은 동등하지 않다.(2장 값 참고)

마지막 항목(11.9.3.1). 객체(함수와 배열 포함)의 느슨한 동등 비교에 대해 두 객체가 정확히 똑같은 값에 대한 레퍼런스일 경우에만 동등하다고 기술되어 있다. 여기서 강제변환은 일어나지 않는다.

NOTE: 11.9.3.6을 보면 === 역시 두 객체 값 비교 방법에 대해 똑같이 기술되어 있다. 객체의 동등 비교에 있어서 ==와 ===의 로직이 똑같다는 사실은 거의 알려져 있지 않다.

11.9.3 알고리즘 나머지 부분에서는 타입이 다른 두 값을 느슨한 동등 비교(==)시, 한쪽 또는 양쪽 피연산자에서 암시적 강제변환을 어떻게 해야 하는지 씌어 있다. 결과적으로 두 값의 타입을 일치시켜 간단히 값만 보고 비교하기 위함이다.

NOTE: 짐작하겠지만, !=의 결괏값은 == 연산자의 동등 비교 수행 후 그 결과를 부정한 값이다. !== 역시 마찬가지.

#### 비교하기: 문자열 -> 숫자

앞서 보았던 문자열/숫자 예제로 돌아가 == 강제변환을 살펴보자.

```js
var a = 42;
var b = "42";

a === b;	// false
a == b;		// true
```

예상대로 a === b 는 false다. 강제변환이 허용되지 않는 데다 42와 "42"는 그냥 봐도 다른 값이기 때문이다.

하지만 느슨한 동등 비교 a == b 에서는 피연산자의 타입이 다르면, 비교 알고리즘에 의해 한쪽 또는 양쪽 피연산자 값이 알아서 암시적으로 강제변환 된다.

그런데 정확히 어떻게 강제변환이 일어나는 걸까?

ES5 11.9.3.4 - 5 원문을 보자.
1. Type (x)가 Number이고 Type (y)가 String이면, x == ToNumber (y) 비교 결과를 반환한다.
2. Type (x)가 String이고 Type (y)가 Number면, TonNmber(x) == y 결과를 반환한다.

명세를 보니 비교 전 먼저 "42" 값이 숫자로 강제변환된다는 것을 분명히 알 수 있다.

#### 비교하기: * -> boolean

어떤 값을 true/false와 직접 비교하려고 하면 느슨한 동등 비교(==)의 숨겨진, 가장 끔찍한 강제변환 함정에 빠지게 될 것이다.

```js
var a = "42";
var b = true;

a == b;	// false
```

"42"는 truthy 값이니 true가 되야 될텐데???

ES5 11.9.3.6 - 7 을 인용한다.
1. Type (x)가 boolean이면 ToNumber(x) == y의 비교 결과를 반환한다.
2. Type (y)가 boolean이면 x == ToNumber(y)의 비교 결과를 반환한다.

```js
var x = true;
var y = "42";

x == y; // false
```

Type(x)는 boolean 이므로 ToNumber(x) -> 1로 강제변환된다. 따라서 1 == "42"가 된다. 타입이 다르기 때문에 한번 더 알고리즘을 수행한다. 결국 "42"는 42로 바뀌어 1 == 42 -> false가 된다.

순서를 바꿔도 마찬가지.

```js
var x = "42";
var y = false;

x == y; // false
```

이번에는 Type (y)가 boolean 이므로 ToNumber(y)는 0, "42" == 0 -> 42 == 0 -> false다.

결론적으로 "42"는 == true도, == false도 아니다. 뭔 소리?

"42"는 분명 truthy한 값. "42" == true는 true가 1로 강제변환되고 그 후 "42"가 42로 강제변환된다.

이런 방식이 마음에 안들어도 어쨋든 ToBoolean은 전혀 개입하지 않으며, "42" 값 자체의 truthy/falsy 여부는 == 연산과는 전혀 무관하다!

==의 피연산자 한쪽이 boolean 값이면 예외 없이 그 값이 먼저 숫자로 강제변환 된다.

그러니까 *절대로, 두 번 다시 == true, == false 같은 코드는 쓰지 말라고 개인적으로 강권하고 싶다.*

그렇지만 === true, === false는 강제변환을 허용하지 않기에 ToNumber 강제변환 따위는 신경 쓰지 않아도 된다.

```js
var a = "42";

// 나빠 (실패한다!):
if (a == true) {
	// ..
}

// 이것도 나빠 (실패한다!):
if (a === true) {
	// ..
}

// 그럴듯해 (암시적으로 작동):
if (a) {
	// ..
}

// 더 낫네 (명시적으로 작동):
if (!!a) {
	// ..
}

// 이것도 좋아 (명시적으로 작동):
if (Boolean( a )) {
	// ..
}
```

그냥 앞으로 == true, == false 같은 코드를 쓰지 말자.

#### 비교하기: null -> undefined

null과 undefined간의 변환은 느슨한 동등 비교 ==이 암시적 강제변환을 하는 또 다른 예다. ES5 11.9.3.2 - 3을 인용한다.
1. x가 null이고 y가 undefined면 true를 반환한다.
2. x가 undefined이고 y가 null이면 true를 반환한다.

null과 undefined는 느슨한 동등 비교 시 상호 간의 암시적인 강제변환이 일어나므로 비교 관점에서 구분이 되지 않는 값으로 취급된다.

```js
var a = null;
var b;

a == b;		// true
a == null;	// true
b == null;	// true

a == false;	// false
b == false;	// false
a == "";	// false
b == "";	// false
a == 0;		// false
b == 0;		// false
```

'null <-> undefined' 강제변환은 안전하고 예측 가능하며, 어떤 다른 값도 비교 결과 긍정 오류를 할 가능성이 없다.(null과 undefined 자신들끼리 비교 결과가 true이므로, 이외의 값들과 비교했을 때 결괏값이 true일 가능성은 없다) null과 undefined를 구분되지 않는 값들로, 결국 동일한 값으로 취급하는 강제변환은 권장하고 싶다.

```js
var a = doSomething();

if (a == null) {
	// ..
}
```

a == null의 평가 결과는 doSomething()이 null이나 undefined를 반환할 경우에만 true. 이외의 값이 반환되면 (심지어 0, false, ""등의 다른 falsy한 값이 넘어와도) false다.

명시적으로 체크한 다음 코드는 (내 주관으로) 쓸데없이 흉흉하기만 하다.(사소하지만 성능도 약간 떨어진다!)

```js
var a = doSomething();

if (a === undefined || a === null) {
	// ..
}
```

a == null 같은 코드는 가독성 좋고 안전하게 작동하는 암시적 강제변환의 일례다.

#### 비교하기: 객체 -> 비객체

객체/함수/배열과 단순 스칼라 원시 값(문자열, 숫자, 불리언)의 비교는 ES5 11.9.3.8 - 9 에서 다룬다.

1. Type (x) 가 String 또는 Number고 Type (y)가 객체라면, x == ToPrimitive (y)의 비교 결과를 반환한다.
2. Type (x) 가 Object이고 Type (y)가 String 또는 Number이면, ToPrimitive (x) == y의 비교 결과를 반환한다.

NOTE: 이미 Boolean 피연산자는 Number 타입으로 강제변환하는 내용을 앞에서 다룸.

```js
var a = 42;
var b = [ 42 ];

a == b;	// true
```

[ 42 ] 는 ToPrimitive 추상 연산 결과, "42"가 된다. 그리고 "42" == 42 -> 42 == 42 이므로 a, b 는 동등하다.

3장 네이티브에서 배운 '언박싱'을 상기하자. 원시 값을 감싼 객체 래퍼(예: new String("abc"))를 한 꺼풀 벗겨 원시 값("abc")을 반환하는 과정이다. 언박싱은 == 알고리즘의 ToPrimitive 강제변환과 관련되어 있다.

```js
var a = "abc";
var b = Object( a );	// `new String( a )`와 같다.

a === b;				// false
a == b;					// true
```

b는 ToPrimitive 연산으로 "abc"라는 단순 스칼라 원시 값으로 강제변환되고('언박싱'으로 벗겨지고) 이 값은 a와 동일하므로 a == b true가 맞다.

하지만 항상 그런 것은 아니다. == 알고리즘에서 더 우선하는 규칙 때문에 그렇지 않은 경우들도 있다.

```js
var a = null;
var b = Object( a );	// `Object()` 와 같다.
a == b;					// false

var c = undefined;
var d = Object( c );	// `Object()` 와 같다.
c == d;					// false

var e = NaN;
var f = Object( e );	// `new Number( e )` 와 같다.
e == f;					// false
```

null과 undefined는 객체 래퍼가 따로 없으므로 박싱할 수 없다. 그래서 Objet (null)은 Object()로 해석되어 그냥 일반 객체가 만들어진다.

NaN은 해당 객체 래퍼인 Number로 박싱되지만, == 를 만나 언박싱되면 결국 조건식은 NaN == NaN이 되어 false가 된다.(2장 값 참고)

### 4-5-3 희귀 사례

이 절에서는 여러분들이 가장 골치 아프고 쓰지 말아야할, 희귀 사례를 골라 소개할 것이다.

먼저 내장 네이티브 프로토타입을 변경하면 어떤 참사가 빚어지는지 살펴보자.

#### 알 박힌 숫자 값

```js
Number.prototype.valueOf = function() {
	return 3;
};

new Number( 2 ) == 3;	// true
```

NOTE: 2 == 3 비교는 이 예와 무관한다. 2, 3 둘 다 이미 원시 숫자 값이므로 곧바로 비교가 가능하다. 그러나 new Number(2)는 무조건 ToPrimitive 강제변환 후 valueOf()를 호출한다.

어휴 이런 코드는 흉내도 내지 맙시다요.

다음 사례는 아까보다 훨씬 까다롭다.

```js
if (a == 2 && a == 3) {
	// ..
}
```

동시에 2와 3이 되는게 말이되나? 엄밀히 말해, 두 표현식 중 a == 2가 먼저 평가 된다.

a.valueOf()에 효과를 주어서 처음 호출하면 2, 두번째 호출하면 3이 되도록 수정하면 어떻게 될까?

```js
var i = 2;

Number.prototype.valueOf = function() {
	return i++;
};

var a = new Number( 42 );

if (a == 2 && a == 3) {
	console.log( "이런 정말 되네." );
}
```

이런 코드는 그 자체로 공해니 생각도 말자! 강제변환을 비난하는 그건로 제시하지도 말자. 말도 안되는 장난은 피하면 그만이고 올바르게, 적절하게 강제변환을 이용하자.

#### Falsy 비교

==의 암시적 강제변환을 힐난하는 사람들은 falsy 값 비교에 관한 이상한 로직을 종종 거론한다.

falsy 값 비교에 관한 희귀 사례 목록을 보면서 정상과 비정상을 구별해보자.

```js
"0" == null;			// false
"0" == undefined;		// false
"0" == false;			// true -- 어이쿠!
"0" == NaN;				// false
"0" == 0;				// true
"0" == "";				// false

false == null;			// false
false == undefined;		// false
false == NaN;			// false
false == 0;				// true -- 어이쿠!
false == "";			// true -- 어이쿠!
false == [];			// true -- 어이쿠!
false == {};			// false

"" == null;				// false
"" == undefined;		// false
"" == NaN;				// false
"" == 0;				// true -- 어이쿠!
"" == [];				// true -- 어이쿠!
"" == {};				// false

0 == null;				// false
0 == undefined;			// false
0 == NaN;				// false
0 == [];				// true -- 어이쿠!
0 == {};				// false
```

여기서 "어이쿠!"라고 주석을 붙인 7개의 비교는 긍정 오류(False Positive)이며, 개발자를 뜬눈으로 지새우게 할 소지가 다분하다. ""와 0은 분명히 다른 값이며 같은 값으로 취급할 경우 또한 거의 없기 때문에 상호 강제변환은 문제가 있다. (7개 비교 중 부정 오류는 하나도 없다)

#### 말도 안되는...

더 심각한 강제변환 사례도 있다.

```js
[] == ![]; // true
```

truthy와 falsy의 비교가 아닌가 싶은데, 어떻게 된걸까?

!단항 연산자는 ToBoolean으로 불리언 값으로 명시적 강제변환을 하는 (그리고 패리티를 전부 뒤집는) 연산자다. 따라서 [] == false로 바뀐다.

다음 사례도 비슷하다.

```js
2 == [2];		// true
"" == [null];	// true
```

배열의 valueOf() 메서드는 배열 자신을 반환하므로 강제변환 시 배열을 문자열화한다.

따라서 첫째 줄의 [2]는 "2"가 되고 다시 ToNumber 강제변환을 거쳐 2가 된다. [null]은 바로 ""이 된다.

이런 결과가 마음에 들지 않는다면 '배열->문자열' 강제변환 시 ToPrimitive가 수행하는 로직이 싫은 것이다. 즉, [2].toString()이 "2"를 반환하고 [null].toString()이 ""를 반환하는 형태 자체가 못마땅한 것이다.

그럼 과연 어떻게 문자열로 강제변환해야 맞는걸까?

다음 사례 역시 유명하다.

```js
0 == "\n";		// true
```

공백 문자 " ", "\n" 가 ToNumber를 경유하여 0으로 강제변환된다는 사실은 앞에서 언급했다. 그러면 " "를 숫자로 강제변환한 결과로 0 이외에 마땅한 대안이 있을까?

희귀한 타입변환 사례는 어느 언어에나 항상 있기 마련이고 강제변환에 국한된 문제는 아니다.

여러분이 맞닥뜨릴 가능성이 조금이라도 있는, 평범한 값 사이에서 이상하게 작동하는 강제변환은 방금전 열거한 7가지가 전부라도 보면 된다.
> "0" == false, false == 0, false == "", false == [], "" == 0, "" == [], 0 == [] 전부 true! 24가지 사이에 있어서 따로 나열해 봄.

다음 코드를 24인의 강제변환 수배범 명단과 대조해보자.

```js
42 == "43";							// false
"foo" == 42;						// false
"true" == true;						// false

42 == "42";							// true
"foo" == [ "foo" ];					// true
```