# CHAPTER 4 강제변환

이 장의 목적은 강제변환의 좋고 나쁨을 충분히 이해하고 자신이 프로그램에 적절한지 스스로 판달할 수 있는 역량을 늘리기다.

* [4-1 값 변환](#4-1-값-변환)
* [4-2 추상 연산](#4-2-추상-연산)
* [4-3 명시적 강제변환](#4-3-명시적-강제변환)
* [4-4 암시적 변환](#4-4-암시적-변환)

## 4-1 값 변환

어떤 값을 다른 타입의 값으로 바꾸는 과정이 명시적이면 '타입 캐스팅(Type Casting)', (값이 사용되는 규칙에 따라) 암시적이면 '강제변환(Coercion)'이라고 한다.

자바스크립트에서는 대부분 모든 유형의 타입변환을 강제변환으로 뭉뚱그려 일컫는 경향이 많다. 여기서는 '암시적 강제변환(Explicit Coercion')'과 '명시적 강제변환(Implicit Coercion)' 두 가지로 구별하겠다.

* 명시적 강제변환 : 코드만 봐도 의도적으로 타입변환을 일으킨다는 사실이 명백
* 암시적 강제변환 : 다른 작업 도중 불분명한 부수 효과로부터 발생하는 타입변환

```js
var a = 42;

var b = a + "";			// 암시적 강제변환

var c = String( a );	// 명시적 강제변환
```

두 가지 접근 방식 모두 42를 "42"로 바꾸는데, 여기서 논란의 핵심은 변환을 '어떻게' 할 것이냐 하는 문제다.

## 4-2 추상 연산

어떻게 값이 문자열, 숫자, 불리언 등의 타입이 되는지, 그 기본 규칙을 알아보자.

### 4-2-1 ToString

'문자열이 아닌 값 -> 문자열' 변환 작업은 ES5 9.8의 ToString 추상 연산 로직이 담당한다. 내장 원시 값은 본연의 문자열화 방법이 정해져 있다.(null -> "null", undeinfed -> "undefined", true -> "true") 숫자는 그냥 문자열로 바뀌고 너무 작거나 큰 값은 지수 형태로 바뀐다.(2장 값 참고).

```js
// `1.07` 에 `1000`을 7번 곱한다
var a = 1.07 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000;

// 소수점 이하로 3 x 7 => 21자리까지 내려간다
a.toString(); // "1.07e21"
```

일반 객체는 특별히 지정하지 않으면 기본적으로 (Object.prototype.toString()에 있는) toString() 메서드가 내부 [[Class]]를 반환한다.(예: "[object Object]") 자신의 toString() 메서드를 가진 객체는 문자열처럼 사용하면 자동으로 이 메서드가 호출된다.

배열은 기본적으로 재정의된 toString()이 있다. 문자열 변환 시 모든 원소 값이 (각각 문자열로 바뀌어) 콤마로 분리된 형태로 이어진다.

```js
var a = [1,2,3];
a.toString(); // "1,2,3"
```

또한 toString() 메서드는 명시적으로도 호출 가능하며, 문자열 콘텍스트에서 문자열 아닌 값이 있을 경우에도 자동 호출된다.

#### JSON 문자열화

JSON 문자열화는 강제변환과 똑같지는 않지만, 방금 전 살편본 ToString 규칙과 관련이 있다.

대부분 단순 값들은 직렬화 결과가 반드시 문자열이라는 점을 제외하고는, JSON 문자열화나 toString() 변환이나 기본적으로 같은 로직이다.

```js
JSON.stringify( 42 );	// "42"
JSON.stringify( "42" );	// ""42"" (따옴표가 붙은 문자열 인자를 문자열화한다)
JSON.stringify( null );	// "null"
JSON.stringify( true );	// "true"
```

JSON 안전 값(JSON-Safe Value)은 모두 JSON.stringfy()로 문자열화할 수 있다. (아닌 예: undefined, 함수, Symbol, 환형 참조 객체)

JSON.stringfy() 인자가 undefined, 함수, 심벌 값이면 자동으로 누락시키며 이런 값들이 만약 배열에 포함되어 있으면 (배열 인덱스 정보가 뒤바뀌지 않도록) null로 바꾼다. 객체 프로퍼티에 있으면 간단히 지운다.

```js
JSON.stringify( undefined );					// undefined
JSON.stringify( function(){} );					// undefined

JSON.stringify( [1,undefined,function(){},4] );	// "[1,null,null,4]"
JSON.stringify( { a:2, b:function(){} } );		// "{"a":2}
```

혹시라도 JSON.stringfy()에 환형 참조 객체를 넘기면 에러가 난다.

객체 자체에 toJSON() 메서드가 정의되어 있다면, 먼저 이 메서드를 호출하여 직렬화한 값을 변환한다.

부적절한 JSON 값이나 직렬화하기 곤란한 객체 값을 문자열화하려면 toJSON() 메서드(해당 객체의 JSON 안전 버전을 반환)를 따로 정의해야 한다.

```js
var o = { };

var a = {
	b: 42,
	c: o,
	d: function(){}
};

// `a`를 환형 참조 객체로 만든다
o.e = a;

// 환형 참조 객체는 JSON 문자열화 시 에러가 난다
// JSON.stringify( a );

// JSON 값으로 직렬화하는 함수를 따로 정의한다
a.toJSON = function() {
	// 직렬화에 프로퍼티 'b'만 포함시킨다.
	return { b: this.b };
};

JSON.stringify( a ); // "{"b":42}"
```

toJSON()은 (어떤 타입이든) 적절히 평범한 실제 값을 반환하고 문자열화 처리는 JSON.stringfy()이 담당한다. 다시 말해 toJSON()의 역할은 '문자열화하기 적당한 JSON 안전 값으로 바꾸는 것'이지, 'JSON 문자열로 바꾸는 것'이 아니다.

```js
var a = {
	val: [1,2,3],

	// 맞다!
	toJSON: function(){
		return this.val.slice( 1 );
	}
};

var b = {
	val: [1,2,3],

	// 틀리다!
	toJSON: function(){
		return "[" +
			this.val.slice( 1 ).join() +
		"]";
	}
};

JSON.stringify( a ); // "[2,3]"

JSON.stringify( b ); // ""[2,3]"
```

b는 배열 자체가 아니라 반환된 문자열을 다시 문자열화한다.

배열 아니면 함수 형태의 대체자(Replace)를 JSON.stringfy()의 두 번째 선택 인자로 지정하여 객체를 재귀적으로 직렬화하면서 (포함할 프로퍼티와 제외할 프로퍼티를 결정하는) 필터링 하는 방법이 있다. toJSON()이 직렬화할 값을 준비하는 방식과 비슷하다.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, ["b","c"] ); // "{"b":42,"c":"42"}"

JSON.stringify( a, function(k,v){
	if (k !== "c") return v;
} );
// "{"b":42,"d":[1,2,3]}"
```

JSON.stringfy()는 세 번째 선택 인자는 스페이스라고 하며 사람이 읽기 쉽도록 들여쓰기를 할 수 있다.

```js
var a = {
	b: 42,
	c: "42",
	d: [1,2,3]
};

JSON.stringify( a, null, 3 );
// "{
//    "b": 42,
//    "c": "42",
//    "d": [
//       1,
//       2,
//       3
//    ]
// }"

JSON.stringify( a, null, "-----" );
// "{
// -----"b": 42,
// -----"c": "42",
// -----"d": [
// ----------1,
// ----------2,
// ----------3
// -----]
// }"
```

JSON.stringfy()는 직접적인 강제변환의 형식은 아니지만 두 가지 이유로 ToString 강제 변환과 연관된다.
1. 문자열, 숫자, 불리언, null 값이 JSON으로 문자열화하는 방식은 ToString 추상 연산의 규칙에 따라 문자열 값으로 강제변환되는 방식과 동일하다.
2. JSON.stringfy()에 전달한 객체가 자체 toJSON() 메서드를 갖고 있다면, 문자열화 전 toJSON()이 자동 호출되어 JSON 안전 값으로 '강제변환' 된다. 

### 4-2-2 ToNumber

'숫자 아닌 값 -> 수식 연산이 가능한 숫자' 변환 로직은 ES5 9.3 ToNumber 추상 연산에 잘 정의되어 있다.

ex) true => 1, false => 0, undefined => NaN, (희한하게도) null => 0

문자열 값에 ToNumber를 적용하면 대부분 숫자 리터럴 규칙/구문과 비슷하게 작동한다. 변환이 실패하면 (숫자 리터럴 구문 에러가 아닌) 결과는 NaN이다. 한가지 다른 점은 0이 앞에 붙은 8진수는 ToNumber에서 올바른 숫자 리터럴이라도 8진수로 처리하지 않는다.(일반 10진수로 처리)

객체(그리고 배열)는 일단 동등한 원시 값으로 변환 후 그 결괏값(아직 숫자가 아닌 원시 값)을 ToNumber 규칙에 의해 강제 변환한다.

동등한 원시 값으로 바꾸기 위해 ToPrimitive 추상 연산 과정에서 해당 객체가 valueOf() 메서드를 구현했는지 확인한다. ValueOf()를 쓸 수 있고 반환 값이 원시 값이면 그대로 강제변환 한다. 그렇지 않을 경우 toString() 메서드가 존재하면 toString()을 이용하여 강제변환 한다.

어찌해도 원시 값으로 바꿀 수 없을 땐 TypeError 오류를 던진다.

ES5 부터는 [[Prototype]]이 null인 경우 대부분 Object.create(null)를 이용하여 강제변환이 불가능한 객체(valueOf(), toString()이 없는 객체)를 생성할 수 있다.

```js
var a = {
	valueOf: function(){
		return "42";
	}
};

var b = {
	toString: function(){
		return "42";
	}
};

var c = [4,2];
c.toString = function(){
	return this.join( "" );	// "42"
};

Number( a );			// 42
Number( b );			// 42
Number( c );			// 42
Number( "" );			// 0
Number( [] );			// 0
Number( [ "abc" ] );	// NaN
```

### 4-2-3 ToBoolean

자바스크립트에는 true와 false라는 키워드가 존재한다. 그리고 1을 true로, 0을 false로 (역방향도 마찬가지) 강제변환할 수는 있지만 그렇다고 두 값이 똑같은 건 아니다.

#### Falsy 값

true/false가 아닌 값을 boolean에 상당한 값으로 강제 변환하면 어떻게 작동할까?

다음 둘 중 하나다.
1. boolean으로 강제변환하면 false가 되는 값
2. 1번을 제외한 나머지(즉 명백히 true인 값)

명세가 정의한 'falsy' 값은 다음과 같다.
* undefined
* null
* false
* +0, -0, NaN
* ""

이게 전부다. 이 'falsy' 값을 boolean으로 강제변환하면 false다.

'truthy' 값 목록은 없지만 'falsy' 값 목록에 없으면 응당 'truthy' 값이 된다. (모든 객체도)

| 인자타입 | 결괏값 |
| --- | --- |
| `Undefined` | false |
| `Null` | false |
| `Boolean` | 인자 값과 동일(변환 안함) |
| `Number` | +0, -0, NaN이면 false, 그 외에는 true |
| `String` | 인자가 공백 문자열(length가 0)이면 false, 그 외에는 true |
| `Object` | true |

#### Falsy 객체

뭔 소리? falsy 값을 둘런싼 객체 래퍼 얘기임?

```js
var a = new Boolean( false );
var b = new Number( 0 );
var c = new String( "" );

var d = Boolean( a && b && c );

d; // true
```

a, b, c는 명백히 falsy 값을 감싼 객체다. 하지만 모두 true임을 알 수 있다.

그럼 얘 뭐임?

사실 이 객체는 순수 자바스크립트의 일부가 아니다.

일반적인 자바스크립트의 의미(Semantics) 뿐만 아니라 브라우저만의 특이한 작동 방식을 가진 값을 생성하는 경우가 있는데, 이거싱 바로 'falsy 객체'의 정체다.

'falsy 객체'를 boolean으로 강제변환하면 false다.

why?

가장 유명한 사례

개발자들이 (자바스크립트 엔진이 아닌) DOM에서 사용했던 유사 배열(객체), document.all이다. document.all은 웹 페이지의 요소를 자바스크립트 프로그램에서 가져올 수 있게 해주었고, 그래서 실제로 'truthy'한 일반 객체처럼 작동했다. 하지만 이젠 더 이상 아니다.

document.all은 '비표준'이며, 이미 오래전에 비 권장/폐기되었다.

그냥 날릴수는 없나? 그러기에는 document.all에 의존하는 레거시 코드 베이스가 너무 많았다. (오래된 비표준 IE 부라우저를 감지하는 수단으로 줄곧 사용해옴)

그래서 document.all이 falsy인 것처럼 돌아가게 꼼수 고고씽

결국 브라우저 때문에 말도 안되는 비표준('falsy 객체')이 자바스크립트에 더해진 것이다 ㅠㅠ

#### truthy 값

falsy 값 목록에 없으면 무조건 truthy 값

```js
var a = "false";
var b = "0";
var c = "''";

var d = Boolean( a && b && c );

d;
```

정답은 true. 문자열 값 자체는 모두 truthy.(유일한 falsy 값 문자열은 " "다)

```js
var a = [];				// 빈 배열 -- truthy or falsy?
var b = {};				// 빈 객체 -- truthy or falsy?
var c = function(){};	// 빈 함수 -- truthy or falsy?

var d = Boolean( a && b && c );

d;
```

모두 truthy. (falsy 값 목록에 없기 떄문)

truthy 값은 짱 많음. 그러니 그냥 falsy 값 목록을 외워라!

## 4-3 명시적 강제변환

명시적 강제변환(Explicit Coercion)은 분명하고 확실한 타입변환이다. 개발자들이 흔히 사용하는 타입변환은 대개 이 명시적 강제변환 범주에 속한다.

명시적 강제변환은 정적 타입 언어에서 지극히 당연하다고 여겨지는 타입변환의 관례를 충실히 따르고 있기에 별다른 논쟁거리는 없다. 그러니 당연하게 받아들이자.

### 4-3-1 명시적 강제변환: 문자열 -> 숫자

'문자열<->숫자' 강제변환은 String()과 Number() 함수를 이용하는데, 앞에 new 키워드가 붙지 않기 때문에 *객체 래퍼를 생성하는 것이 아니다*.

```js
var a = 42;
var b = String( a );

var c = "3.14";
var d = Number( c );

b; // "42"
d; // 3.14
```

각각 ToString, ToNumber 추상 연산 로직에 의해 숫자 값으로 강제변환한다.

누가 봐도 결과적으로 타입변환이 일어난다는 사실은 의심할 여지가 없으므로 '명시적 강제변환'이 맞다.

사실 이러한 사용법은 다른 정적 타입 언어와 비슷하다.(ex C/C++ (int)x, int(x))

String()과 Number() 이외에도 '문자열<->숫자'의 '명시적인' 타입변환 방법은 또 있다.

```js
var a = 42;
var b = a.toString();

var c = "3.14";
var d = +c;

b; // "42"
d; // 3.14
```

a.toString() 호출은 겉보기엔 명시적이지만, 몇 가지 암시적인 요소가 감춰져 있다. 원시 값 42에는 toString() 메서드가 없으므로 엔진은 toString()을 사용할 수 있게 자동으로 42를 객체 래퍼로 '박싱'한다. 말하자면 '명시적으로 아시적인' 작동이다.

+c의 +는 단항 연산자다. 덧셈이 아니라 피연산자 c를 숫자로, 명시적 강제변환한다. (오픈 소스 자바스크립트 커뮤니티에서는 + 단항 연산자를 명시적 강제변환 형식으로 대부분 인정하는 분위기다.)

설사 +c처럼 쓰는 걸 좋아하는 사람이라도 헷갈리는 경우가 있다.

```js
var c = "3.14";
var d = 5+ +c;

d; // 8.14
```

- 단항 연산자 역시 +처럼 강제변환을 하지만 부호를 뒤바꿀 수 있다. 그렇다고 --로 하면 증감연산자가 되니 공란을 넣어주자. - -"3.14 => 3.14로 강제 변환

이런 식으로 단항 연산자 뒤에 이진 연산자를 붙이면 헬이 될 수 있다.

```js
1 + - + + + - + 1;	// 2
```

가급적 +/- 단항 연산자를 다른 연산자와 인접하여 사용하지 말자. d = +c (또는 d =+ c)는 d에 c를 더하는 d += c 와 완전히 다른 코드.

명시적으로 변환하여 문제를 악화시키지 말고 혼동을 줄이는게 좋다!

#### 날짜 -> 숫자

+ 단항 연산자는 'Date 객체 -> 숫자' 강제변환 용도로도 쓰인다. 결괏값이 날짜/시각 값을 유닉스 타임스탬프 표현형이기 때문이다.

```js
var d = new Date( "Mon, 18 Aug 2014 08:53:06 CDT" );

+d; // 1408369986000
```

다음과 같이 현재 시각을 타임스탬프로 바꾸는 관용적인 방법.

```js
var timestamp = +new Date();
```

강제변환을 하지 않고 Date 객체로부터 타임스탬프를 얻는 방법이 있는데 강제변환 보다 더 명시적이다.

```js
var timestamp = new Date().getTime();
// var timestamp = (new Date()).getTime();
// var timestamp = (new Date).getTime();
```

하지만 ES5에 추가된 정적 함수 Date.now()를 쓰는게 더 낫다.

```js
var timestamp = Date.now();
```

폴리필

```js
if (!Date.now) {
	Date.now = function() {
		return +new Date();
	};
}
```

날짜 타입에는 강제변환 비추. 현재 타임스탬프는 Date.now(), 그 외 특정 날짜/시간의 것은 new Date().getTime()을 쓰자.

#### 이상한 나라의 틸드(~)

비트 연산을 하면 피연산자는 32비트 값으로 강제로 맞춰지는데, ToInt32 추상 연산이 이 역할을 맡는다.

우선 ToInt32는 ToNumber 강제변환 한다. "123"이라면 ToInt32 규칙을 적용하기 전 123으로 바꾼다.

엄밀히 말해 이 자체는 (타입이 바뀐 것은 아니므로!) 강제변환이 아니지만, 숫자 값에 | 나 ~ 비트 연산자를 적용하면 전혀 다른 숫자 값을 생성하는 강제변환 효과가 있다.

0 | x 의 'OR' 연산자(|)는 사실상 ToInt32 변환만 수행한다.

```js
0 | -0;			// 0
0 | NaN;		// 0
0 | Infinity;	// 0
0 | -Infinity;	// 0
```

이러한 특수 숫자들은(64비트 IEEE 754 표준) 32비트로 나타내는 것이 불가능하므로 ToInt32 연산 결과는 0 이다.

0 | __ 변환은 명세서 관점에서 보면 명시적이지만 비트 연산을 이해하지 못하는 사람에게는 암시적인 마법으로 보일 수 있다. 여기서는 다른절과 설명을 위해 명시적으로 하겠다.

~ 연산자는 먼저 32비트 숫자로 '강제변환'한 후 NOT 연산을 한다(각 비트를 거꾸로!)

~는 2의 보수를 구한다. ~x는 대략 -(x + 1)과 같다.

```js
~42;	// -(42+1) ==> -43
```

-(x + 1)의 결과가 0으로 만드는 유일한 값은 -1이다. 일정 범위 내의 숫자 값에 ~ 연산을 할 경우 입력 값이 -1이면 (false로 쉽게 강제변환할 수 있는) falsy한 0, 그 외엔 truthy한 숫자 값이 산출된다.
> Number의 falsy 목록은 +0, -0, NaN 3가지!. 뒤에 나오는 ~a.indexof( "lo" ) 값이 -4가 되는데 -4는 falsy 목록에 없으므로 true가 된다. 헷갈리는 부분이 있어 적어 놓는다.

여기서 -1과 같은 성질의 값을 흔히 '경계 값(Sentinel Value)'이라고 일컫는다. 예를 들어 C 언어의 함수는 대게 -1을 경계 값으로 사용.(return >= 0는 '성공', return -1 은 '실패')

마찬가지로 자바스크립트 문자열 메서드 indexOf()는 특정 문자를 검색하고 발견하면 0부터 시작하는 숫자 값(index)을, 발견하지 못했을 경우 -1을 반환한다.(사실 어떤 하위 문자열이 다른 문자열에 포함되어 있는지 조사하는 용도로 더 많이 사용)

```js
var a = "Hello World";

if (a.indexOf( "lo" ) >= 0) {	// true
	// found it!
}
if (a.indexOf( "lo" ) != -1) {	// true
	// found it
}

if (a.indexOf( "ol" ) < 0) {	// true
	// not found!
}
if (a.indexOf( "ol" ) == -1) {	// true
	// not found!
}
```

>= 0 이나 == -1 같은 코드는 좀 지전분해 보임. 이런 부류의 코드는 '구멍 난 추상화(Leacky Abstraction)', 즉 (경계 값 -1을 '실패'로 정해버린) 내부 구현 방식을 내가 짠 코드에 심어놓은 꼴이다. 이런 부분은 감추는게 더 낫다고 생각한다.

그러니까 indexOf()에 ~를 붙이면 어떤 값을 '강제변환'(실제로는 단순히 변형)하여 Boolean 값으로 적절하게 만들 수 있다.

```js
var a = "Hello World";

~a.indexOf( "lo" );			// -4   <-- truthy!

if (~a.indexOf( "lo" )) {	// true
	// 찾았다!
}

~a.indexOf( "ol" );			// 0    <-- falsy!
!~a.indexOf( "ol" );		// true

if (!~a.indexOf( "ol" )) {	// true
	// 못 찾았다!
}
```

~은 indexOf()로 검색 결과 '실패'시 -1을 falsy한 0으로, 그 외에는 truthy한 값으로 바꾼다.

Note : -(x+1)은 ~의 의사 알고리즘으로, 내부적으로 ~-1을 -0으로 만들지만, 수학 연산이( 아닌 비트 연산이므로 결괏값은 0이 된다.

#### 비트 잘라내기

숫자의 소수점 이상 부분을 잘라내기(truncate) 위해 (즉, 완전수로 '강제변환'하려고) 더블 틸드 ~~를 사용하는 개발자들이 있다. 흔히들 이렇게 하면 Math.floor()와 같은 결과가 나온다고 생각한다.

~~가 하는 일은 이렇다. 먼저 맨 앞의 ~는 ToInt32 '강제변환'을 적용한 후 각 비트를 거꾸로 한다. 그리고 두 번째 ~는 비트를 또 한 번 뒤집는데, 결과적으로 원래 상태로 되돌린다. 결국 ToInt32 '강제변환'(잘라내기)만 하는 셈이다.

그러나 ~~ 사용 시 유의할 점이 있다. 우선 ~~ 연산은 32비트 값에 한하여 안전하다. 그런데 그보다도 *음수에서는 Math.floor()와 결괏값이 다르다는 사실*을 조심하자!

```js
Math.floor( -49.6 );	// -50
~~-49.6;				// -49
```

~~x는 (32비트) 정수로 상위 비트를 잘라낸다. 하지만 같은 일을 하는 x | 0 가 (조금이더라도) 더 빠를 것 같은데??

하지만 연산자 우선순위(5장 문법 참고)를 생각해서 x | 0 대신 ~~x를 사용하자.

```js
~~1E20 / 10;		// 166199296

1E20 | 0 / 10;		// 1661992960
(1E20 | 0) / 10;	// 166199296
```

이전에 제시한 다른 조언들과 마찬가지로 주변 동료 개발자들이 이해하고 있다는 전제하에 ~와 ~~를 명시적인 '강제변환' 및 값 변형 장치로 잘 활용하자.

## 4-4 암시적 변환

암시적 강제변환의 목적은 중요한 내용으로부터 주의를 분산시켜 코드를 잡동사니로 가득 채워버리는 장황함, 보일러플레이트, 불필요한 상세 구현을 줄이는 것이다.

### 4-4-1 '암시적'이란?

```js
SomeType x = SomeType( AnotherType( y ) )

SomeType x = SomeType( y )
```

엄격한 타입언어의 의사코드를 가정했을 때 위의 2가지 코드 중 아래와 같이 쓰면 타입변환을 단순화 할 수 있다. 단순화시킨 타입변환 코드가 실제로 코드 가독성을 높이고 세세한 구현부를 추상화하거나 감추는데 도움이 된다고 생각한다.

완벽한 비유는 아니지만 핵심은 자바스크립트의 암시적 강제변환 역시 같은 이치로 우리가 작성하는 코딩에 도움이 될 수 있다는 것이다.

암시적 강제변환의 '나쁜 단면'을 보고 나서 전체가 다 나쁘다고 단정하지 말자. 부디 객관적으로 암시적 강제변환을 바라보고 수용하자.

### 4-4-2 암시적 강제변환: 문자열 <-> 숫자

+연산자는 '숫자의 덧셈, 문자열 접합' 두 가지 목적으로 오버로드 된다. 자바스크립트 엔진은 어떻게 판단할까?

```js
var a = "42";
var b = "0";

var c = 42;
var d = 0;

a + b; // "420"
c + d; // 42
```

피연산자가 한쪽 또는 양쪽 모두 문자열인지 아닌지에 따라 +연산자가 문자열 붙이기를 할지 결정한다고 보통 잘못 알고 있는 경우가 많다. 부분적으로 맞지만 더 복잡하다.

```js
var a = [1,2];
var b = [3,4];

a + b; // "1,23,4"
```

a,b 모두 문자열이 아니지만 분명히 둘 다 문자열로 강제변환된 후 접합됐다.

+알고리즘(피연산자가 객체 값일 경우)은 한쪽 피연산자가 문자열이거나 다음 과정을 통해 문자열 표현형으로 나타낼 수 있으면 문자열 붙이기를 한다.

ToPrimitive 추상 연산 -> number 콘텍스트 힌트를 넘겨 [[DefaultValue]] 알고리즘을 호출

정리하면 + 연산의 한쪽 피연산자가 문자열이면(또는 처리를 통해 문자열이 되면) +는 문자열 붙이기 연산을 한다. 그 밖에는 언제나 숫자 덧셈을 한다.

NOTE : 잘 알려진 강제변환 함정. [] + {} => "[object Object]" , {} + [] => 0

근데 이게 암시적 강제변환과 무슨 상관?

숫자는 공백 문자열 ""과 더하면 간단히 문자열로 강제변환된다.

```js
var a = 42;
var b = a + "";

b; // "42"
```

a + ""는 숫자를 문자열로 (암시적) 강제변환하는 아주 흔한 관용 코드다.

ToPrimitive 연산 과정에서 a + ""는 a 값을 valueOf() 메서드에 전달하여 호출하고, 그 결괏값은 ToString 추상 연산을 하여 최종적인 문자열로 변환된다. 그러나 String(a)는 toString()을 직접 호출할 뿐이다.

두 방법 모두 문자열을 반환하지만 원시 숫자 값이 아닌 객체라면 결과가 달라질 수 있다.

```js
var a = {
	valueOf: function() { return 42; },
	toString: function() { return 4; }
};

a + "";			// "42"

String( a );	// "4"
```

대부분 상관 없지만 valueOf(), toString() 메서드를 직접 구현한 객체가 있으면 조심하자.

방향을 바꾸어 '문자열->숫자' 암시적인 강제변환을 알아보자.

```js
var a = "3.14";
var b = a - 0;

b; // 3.14
```

-연산자는 숫자 뺼셈 기능이 전부이므로 a - 0 은 a 값을 강제변환한다. ( a * 1 , a / 1 도 마찬가지)

객체 값에 - 연산을 하면? 이전의 +와 비슷하다.

```js
var a = [3];
var b = [1];

a - b; // 2
```

문자열로 강제변환(toString()로 직렬화) 숫자로 강제변환된다. 그리고 마지막엔 - 연산을 한다.

b = String(a)(명시적)과 b = a + ""(암시적)을 비교하자. 둘 다 경우에 따라 유용하게 코드에 쓰일 수 있지만 자바스크립트 프로그램에선 후자를 훨씬 더 많이쓴다. 암시적 강제변환 낫 배드요.
