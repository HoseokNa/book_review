# 함수 vs 블록 스코프

* [3-1 함수 기반 스코프](#3-1-함수-기반-스코프)
* [3-2 일반 스코프에 숨기](#3-2-일반-스코프에-숨기)
* [3-3 스코프 역할을 하는 함수](#3-3-스코프-역할을-하는-함수)
* [3-4 스코프 역할을 하는 블록](#3-4-스코프-역할을-하는-블록)
* [3-5 정리하기](#3-5-정리하기)

## 3-1 함수 기반 스코프

각각의 선언된 함수는 저 마다의 버블을 생성하지만 다른 어떤 자료 구조도 자체적인 스코프를 생성하지 않는다. 뒤에서 살펴보겠지만, 이는 전혀 사실이 아니다. 먼저 함수 스코프와 그 암시적 용례를 살펴보자.

```js
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
    // more code
    var c = 3;
  }
}
```

위의 코드에서 foo()의 스코프 버블을 확이면 a, b, c와 bar를 포함한다. 선언문이 스코프의 어디에 있는지는 중요하지 않다. 스코프 안에 있는 모든 변수와 함수는 그 스코프 버블에 속한다.

a, b, c, bar 모두 foo()의 스코프 버블에 속하므로 foo() 바깥에서는 이들에게 접근할 수 없다.

```js
bar(); // 실패
console.log( a, b, c) // 3가지 모두 실패
```

하지만 이 모든 확인자(a, b, c, foo, bar)는 foo() 안에서 접근할 수 있고, bar() 안에서도 이용할 수 있다(bar() 내부에서 섀도 확인자가 선언되지 않았을 때).

함수 스코프는 모든 변수가 함수에 속하고 함수 전체(심지어 중첩된 스코프에서도)에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다. 이런 디자인 접근버은 상당히 유용하고 자바스크립트 변수의 '동적' 특성을 완전히 살려 다른 타입의 값을 필요에 따라 가져올 수 있지만, 스코프 전체에서 변수가 살아있다는 점이 예상치 못한 문제를 일으킬 수도 있다.

## 3-2 일반 스코프에 숨기

함수에 대한 전통적인 개념은 이렇다.

* 함수를 선언하고 그 안에 코드를 넣는다. 바꿔 생각해보는 것도 꽤 유용하다.
* 작성한 코드에서 임의 부분을 함수 선언문으로 감싼다. 이는 해당 코드를 '숨기는' 효과를 낸다.

이렇게 하면 삼수의 스코프로 둘러싸서 변수와 함수를 '숨길' 수 있다. 그렇다면 코드를 '숨기는' 테크닉이 어디에 유용할까?

사용하는 이유는 여러가지가 있는데, 소프트웨어 디자인 원칙인 '최소 권한 원칙'과 관련이 있다. 이 원칙은 모듈/객체의 API와 같은 소프트웨어를 설계할 때 필요한 것만 최소한으로 남기고 나머지는 '숨겨야' 한다는 것이다.

이 원칙은 어떤 스코프가 변수와 함수를 포함하는지에 관한 문제와도 관련이 있다.

```js
function doSomething(a) {
  b = a + doSomethingElse( a * 2);

  console.log( b * 3);
}

function doSomethinElse(a) {
  return a - 1;
}

var b;
doSomething( 2 ); // 15
```

이 코드에서 변수 b와 함수 doSomethingElse()는 doSomething()이 어떤 작업을 하는지 보여주는 '비공개' 부분이라고 할 수 있다. 변수 b와 doSomethingElse()에 '접근'할 수 있도록 내버려 두는 것은 불필요할 뿐 아니라 '위험' 할 수 있다.

다음과 같이 doSomething() 스코프 내부에 숨겨야 적절하다.

```js
function doSomething(a) {
  function doSomethinElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse( a * 2);

  console.log( b * 3);
}

doSomething( 2 ); // 15
```

이제 b와 doSomethingElse()는 외부에서 접근할 수 없어서 더는 바깥의 영향을 받지 않고, 오직 doSomething()만이 이들을 통제한다. 기능과 최종 결과는 달라지지 않았지만, 벼녁ㅇ된 디자인은 비공개로 해야 할 내용을 확실하게 비공개로 둔다.

### 3-2-1 충돌 회피

변수와 함수를 스코프 안에 '숨기는 것'의 또 다른 장점은 같은 이름을 가졌지만 다른 용도를 가진 두 확인자가 충돌하는 것을 피할 수 있다는 점이다.

```js
function foo() {
  function bar(a) {
    i = 3; // 스코프 안에 있는 i 값을 바꾼다
    // for-loop
    console.log( a + i );
  }

  for (var i = 0 ; i < 10; i++) {
    bar( i * 2 ); // 무한 루프!
  }
}

foo();
```

boo() 내부의 대입문 "i = 3" 때문에 i 의 값이 3으로 고정되어 for문이 무한루프에 빠지게 된다.

bar() 내부의 대입문은 어떤 확인자 이름을 고르든 지역 변수로 선언해서 사용해야 한다. "var i = 3;" 으로 변경하면 문제를 해결할 수 있다.(앞서 언급한  i에 대한 '가려진 변수'를 선언하는 것) "var j = 3;"과 같은 다른 확인자 이름을 고르는 방법도 있지만 소프트웨어 설계를 하다 보면 자연스럽게 같은 확인자 이름을 사용하게 된다. 그러므로 스코프를 이용해서 내부에 선언문을 '숨기는' 것이 가장 좋은 선택지다.

#### 글로벌 '네임스페이스'

내부/비공개 함수와 변수가 적절하게 숨겨져 있지 않은 여러 라이브러리를 한 프로그램에서 불러오면 라이브러리들은 서로 쉽게 충돌한다.

이런 라이브러리는 일반적으로 글로벌 스코프에 하나의 고유 이름을 가지는 객체 선언문을 생성한다. 이후 객체는 해당 라이브러리의 '네임스페이스'로 이용된다. 네임스페이스를 통해 최상위 스코프의 확인자가 아니라 속성 형태로 라이브러리의 모든 기능이 노출된다.

```js
var MyReallyCoolLibrary = {
  awesome: "stuff",
  doSomething: function() {
    //
  },
  doAnotherThing: function() {
    //
  }
};
```

#### 모듈 관리
좀 더 현대적인 충돌 방지 옵션으로는 다양한 의존성 관리자를 이용한 '모듈' 접근법이 있다. 이 도구를 사용하면 어떤 라이브러리도 확인자를 글로벌 스코프에 추가할 필요 없이, 특정 스코프로부터 의존성 관리자를 이용한 다양한 명시적인 방법으로 확인자를 가져와 사용할 수 있다.

기억할 것은 이런 도구를 사용한다고 렉시컬 스코프 규칙에서 벗어날 수 있는 것이 아니다. 의존성 관리자는 그저 여기서 설명한 스코프 규칙을 적용해 모든 확인자가 공유 스코프에 누출되는 것을 방지하고, 우발적인 스코프 충돌을 예방하기 위해 충돌 위험이 없는 비공개 스코프에 확인자를 보관한다.

모듈 패턴에 대한 좀 더 자세한 정보는 5장 스코프 클로저를 참고하라.

## 3-3 스코프 역할을 하는 함수

지금까지 코드를 함수로 감싸 내부에 변수나 함수 선언문을 바깥 스코프로부터 함수의 스코프 안에 '숨기는' 것을 살펴보았다.

```js
var a = 2;

function foo() {  // foo 함수 선언
  var a = 3;
  console.log( a ); // 3
}  
foo();  // 호출

console.log(a); // 2
```

이 방식은 동작하기는 하지만, 결코 이상적인 방식은 아니다. 이 방식에는 몇가지 문제가 있다.

첫째, foo()라는 이름의 함수를 선언해야 한다. 즉, foo라는 확인자 이름으로 둘러싸인 스코프(여기서 글로벌 스코프)를 '오염시킨다'는 의미다. 또한, 그 함수를 직접 이름(foo())으로 호출해야만 실제 감싼 코드를 실행할 수 있다.

함수를 이름 없이 (아니면 그 이름이 둘러싸인 스코프를 오염시키지 않고) 선언하고 자동으로 실행된다면 더 이상적일 것이다.

다행히도 자바스크립트에서는 두 가지 문제를 모두 해결할 방법이 있다.

```js
var a = 2;
(function foo(){
  var a = 3;
  console.log(a); // 3 
})();

console.log(a); // 2
```

이 코드에서는 함수는 함수 표현식으로 취급된다.

NOTE: 'function'이 구문의 시작 위치에 있다면 함수 선언문이고, 다른 경우는 함수 표현식이다.

여기서 볼 수 있는 함수 선언문과 함수 표현식의 중요한 차이는 함수 이름이 어디의 확인자로 묶이느냐와 관련이 있다.

앞의 두 코드를 비교해보자. 첫째 코드에서 함수 이름 foo는 함수를 둘러싼 스코프에 묶이고, foo()라는 이름을 통해 직접 호출했다. 두 번째 코드에서 함수 이름 foo는 함수를 둘러싼 스코프에 묶이는 대신 함수 자신의 내부 스코프에 묶였다. 즉 함수 이름 foo를 자기 내부에 숨기면 함수를 둘러싼 스코프를 불필요하게 오염시키지 않는다.

### 3-3-1 익명 vs 기명

다음과 같이 함수 표현식을 콜백 인자로 사용하는 사례에 익숙할 것이다.

```js
setTimeout( function(){
  console.lg("I waited 1 second!");
}, 1000);
```

이런 방식을 '익명 함수 표현식'이라고 부른다. 확인자 이름이 없기 때문이다. 함수 표현식은 이름 없이 사용할 수 있지만, 함수 선언문에는 이름이 빠져서는 안된다. 이름 없는 함수 선언문은 자바스크립트 문법에 맞지 않다.

익명 함수 표현식은 빠르고 쉽게 입력할 수 있는 장점이 있다. 그러나 기억해야할 몇 가지 단점도 있다.

* 익명 함수는 스택 추적 시 표시할 이름이 없어서 디버깅이 더 어려울 수 있다.
* 이름 없이 함수 스스로 재귀 호출을 하려면 폐기 예저인 arguments.callee 참조가 필요하다. 자기 참조가 필요한 또 다른 예로는 한 번 실행하면 해제되는 이벤트 처리 함수가 있다.
* 이름은 보통 쉽게 이해하고 읽을 수 있는 코드 적성에 도움이 되는데, 익명 함수는 이런 이름을 생략한다. 기능을 잘 나타내는 이름은 해당 코드를 그 자체로 설명하는 데 도움이 된다.

인라인 함수 표현식은 매우 효과적이고 유용하다. 함수 표현식에 이름을 사용하면 특별한 부작용 없이 앞의 단점을 해결할 수 있다. 따라서 함수 표현식을 사용할 때 이름을 항상 쓰는 것이 가장 좋다.

```js
setTimeout( function timeoutHandler(){
  console.log( "I waited 1 second!" );
}, 1000);
```

### 3-2-2 함수 표현식 즉시 호출하기
```js
var a = 2;

(function foo()){
  var a= 3;
  console.log(a); //3
}();

consoel.log(a); // 2
```

()로 함수를 감싸면 함수를 표현식으로 바꾸는데, 마지막에 또 다른 ()를 붙이면 함수를 실행할 수 있다. 이것을 즉시 호출 함수 표현식(IIFE)이라고 한다.

IIFE는 익명 함수 표현식으로 가장 흔하게 사용된다. 하지만, 앞서 언급한 것처럼 기명으로 사용하면 더 나은 면이 있다. 따라서 기명 IIFE를 사용하는 것은 좋은 습관이다.

```js
var a = 2;

(function IIFE(){
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

형태를 약간 변형하여 "(function foo(){}())"로 사용하기도 한다. 호출에서 사용되는 ()를 둘러싼 () 안으로 옮겨졌다. 두 형태 모두 똑같이 기능한다. 널리 사용되는 변형은 IIFE가 결국은 함수라는 사실을 이용해 인자를 넘기는 방식이다.

```js
var a = 2;

(function IIFE(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);

console.log(a); // 2 
```

예제에서는 window 객체 참조를 global이라 이름 붙인 인자에 넘겨서 글로벌 참조와 비 글로벌 참조 사이에 명확한 차이를 만들었다.

```js
undefined = true;

(function IIFE(undefined){
  var a;
  if (a === undefined){
    console.log("Undefined is safe here");
  }
})();
```

인자를 undefined 라고 이름 짓고 인자로 아무 값도 넘기지 않으면, undefined 확인자의 값은 코드 블록 안에서 undefined 값을 가진다.

IIFE의 변형된 형태를 하나 더 보자. 여기서 실행할 함수는 호출문과 넘겨진 인자 뒤쪽에 온다. 이 패턴은 UMD(Universal Module Definition) 프로젝트에서 사용한다. 어떤 이들은 이 방식이 약간은 장황해도 이해하기에는 좀 더 깔끔하다고 생각한다.

```js
var a = 2;

(function IIFE(def){
  def(window);
})(funciton def(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
});
```

함수 표현식 def는 코드 후반부에 정의되어 코드 전반부에 정의된 IIFE 함수에 (def라는 이름의) 인자로 넘겨진다. 결국, 인자 함수 def가 호출되고 window가 global 인자로 넘겨진다.

## 3-4 스코프 역할을 하는 블록

블록 스코프의 목적은 변수를 최대한 사용처 가까이에서 최대한 작은 유효 범위를 갖도록 선언하는 것이다.

```js
var foo = true;

if (foo) {
  var bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}
```

변수 bar는 오직 if 문 안에서만 사용하므로, bar를 if 블록 안에 선언하는 것은 타당하다. 그러나 사실 var를 사용할 때 변수를 어디에서 선언하는지는 중요한 문제가 아니다. 선언된 변수는 항상 둘러싸인 스코프에 속하기 때문이다. 위의 코드는 보기에만 스코프처럼 보이는 '가짜' 블록 스코프로, bar를 의도치 않게 다른 곳에서 사용하지 않도록 상기시키는 역할을 할 뿐이다.

블록 스코프는 앞서 언급한 '최소 권한 노출의 원칙'을 확장하여 정보를 함수 안에 숨기고, 나아가 정보를 코드 블록 안에 숨기기 위한 도구다.

```js
for (var i = 0; i < 10; i++) {
  console.log(i);
}
```

오직 for 반복문에서만 사용될 변수 i로 함수 스코프 전체를 왜 오염시켜야 할까?

블록 스코프를 사용한다면(가능했다고 치자) 변수 i는 오직 for 반복문 안에서만 사용할 수 있고, 이외 함ㅅ ㅜ어느 곳에서 접근하더라도 오류가 발생할 것이다. 이는 변수가 혼란스럽고 유지 보수하기 어려운 방식으로 재사용되지 않도록 막는다.

그러나 적어도 외견상으로 자바스크립트는 블록 스코프를 지원하지 않는다. 물론, 좀 더 파고들면 방법은 있다.

### 3-4-1 with

with는 지양해야할 구조이지만 블록 스코프의 형태를 보여주는 한 예다. with 문 안에서 생성된 객체는 바깥 스코프에 영향 주는 일 없이 with 문이 끝날 때까지만 존재한다.

### 3-4-2 try-catch

자바스크립트 ES3에서 try/catch 문 중 catch 부분에서 선언된 변수는 catch 블록 스코프에 속한다.

```js
try {
  undefined(); // 에러 발생
}
catch (err) {
  console.log(err); // 동작!
}

console.log(err); // ReferenceError: 'err' not found
```

catch 문의 블록 스코프 효과는 쓸데없고 학술적인 것처럼 느껴질 수 있지만, 부록 B를 보면 이 기능을 어떻게 유용하게 활용할 수 있는지 알 수 있다.

### 3-4-3 let

키워드 let은 선언된 변수를 둘러싼 아무 블록(일반적으로 {})의 스코프에 붙인다. 바꿔 말해, 명시적이진 않지만 let은 선언한 변수를 위해 해당 블록 스코프를 이용한다고 말할 수 있다.

```js
var foo = true;

if (foo) {
  let bar = foo * 2;
  bar = something(bar);
  console.log(bar);
}

console.log(bar); // ReferenceError
```

let을 이용해 변수를 현재 블록에 붙이는 것은 약간 비명식적이다. 코드를 작성하다 보면 블록이 왔다 갔다 하고 다른 블록으로 감싸기도 하는데, 이럴 때 주의하지 않으면 변수가 어느 블록 스코프에 속한 것인지 착각하기 쉽다.

블록 스코프에 사용하는 블록을 명시적으로 생성하면 이런 문제를 해결할 수 있다.

```js
var foo = true;

if (foo) {
  { // explicit block
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
  }
}

console.log(bar); // ReferenceError
```

그저 {}를 문법에 맞게 추가만 해도 let을 통해 선언된 변수를 묶을 수 있는 임의의 블록을 생성할 수 있다.

2부 4장에서는 호이스팅(Hoisting)에 대해 배울 것이다. 호이스팅은 선언문이 어디에서 선언됐든 속하는 스코프 전체에서 존재하는 것처럼 취급되는 작용을 말한다. 그러나 let을 사용한 선언문은 속하는 스코프에서 호이스팅 효과를 받지 않는다. 따라서 let으로 선언된 변수는 실제 선언문 전에는 명백하게 '존재'하지 않는다.

```js
{
  console.log(bar); // ReferenceError!
  let bar = 2;
}
```

#### 가비지 콜렉션(Garbage Collection)

블록 스코프가 유용한 또 다른 이유는 메모리를 회수하기 위한 클로저 그리고 가비지 콜렉션과 관련 있다. 여기서는 간단히 다루지만, 클로저의 메커니즘은 2부 5장에서 자세히 설명하겠다.

```js
function process(data) {
  // do something interesting
}

var someReallyBigData = {};

process(someReallyBigData);

var btn = document.getElementById("my_button");

btn.addEventListener("click", function click(evt){
  console.log("button clicked");
}, /*capturingPhase=*/false);
```

클릭을 처리하는 click 함수는 someReallyBigData 변수가 전혀 필요 없다. 따라서 이론적으로는 process()가 실행된 후 많은 메모리를 먹는 자료 구조인 someReallyBigData는 수거할 수 있다. 그러나 자바스크립트 엔진은 그 데이터를 여전히 남겨둘 것이다. click 함수가 해당 스코프 전체의 클로저를 가지고 있기 때문이다.

블록 스코프는 엔진에게 someReallyBigData가 더는 필요 없다는 사실을 더 명료하게 알려서 이 문제를 해결할 수 있다.

```js
function process(data) {
  // do something interesting
}

// 이 블록 안에 선언된 어떠한 변수들도 블록과 함께 다른 곳으로 이동할 있다.
{
  var someReallyBigData = {};

  process(someReallyBigData);
}

var btn = document.getElementById("my_button");

btn.addEventListener("click", function click(evt){
  console.log("button clicked");
}, /*capturingPhase=*/false);
```

명시적으로 블록을 선언하여 변수의 영역을 한정한느 것은 효과적인 코딩 방식이므로 익혀두면 좋다.

#### let 반복문

```js
for (let i = 0; i < 10; i++) {
  console.log(i);
}

console.log(i); // ReferenceError
```

let은 단지 i를 for 반복문에 묶었을 뿐만 아니라 반복문이 돌 때마다 변수를 다시 묶어서 이전 반복의 결괏값이 제대로 들어가도록 한다.

다음 예제는 반복마다 다시 묶는 작용을 보여준다.

```js
{
  let j;
  for (j = 0; j < 10; j++) {
    let i = j;  // re-bound for each iteration!
    console.log(i);
  }
}
```

let 선언문은 둘러싼 함수 (또는 글로벌) 스코프가 아니라 가장 가까운 임의의 블록에 변수를 붙인다. 따라서 이전에 var 선언문을 사용해서 작성된 코드는 함수 스코프와 숨겨진 연계가 있을 수 있으므로 코드 리팩토링을 위해서는 단순히 var를 let으로 바꾸는 것 이상의 노력이 필요하다.

```js
var foo = true, baz = 10;

if (foo) {
  var bar = 3;
  if (baz > bar) {
    console.log(baz);
  }

  // ...
}
```

위의 코드는 다음과 같이 쉽게 리팩토링된다.

```js
var foo = true, baz = 10;

if (foo) {
  var bar = 3;
  // ...
}

if (baz > bar) {
  console.log(baz);
}
```

그러나 블록 스코프 변수를 사용한다면 이와 같은 수정을 하기 전에 주의해야 한다.

```js
var foo = true, baz = 10;

if (foo) {
  let bar = 3;

  if (baz > bar) {  // 옮길 때 'bar'를  까먹지 마라
    console.log(baz);
  }
}
```

### 3-4-4 const

ES6에서는 키워드 let과 함께 const도 추가됐다. 키워드 const 역시 블록 스코프를 생성하지만, 선언된 값은 고정된다(상수). 선언된 후 const의 값을 변경하려고 하면 오류가 발생한다.

```js
var foo = true;

if (foo) {
  var a = 2;
  const b = 3; // block-scoped to the containing 'if'
  a = 3; // just fine!
  b = 4; // error
}

console.log(a); // 3
console.log(b); // ReferenceError!
```

## 3-5 정리하기

자바스크립트에서 함수는 스코프를 이루는 가장 흔한 단위다. 다른 함수 안에서 선언된 변수와 함수는 본질적으로 다른 '스코프'로부터 '숨겨진' 것이다. 이는 좋은 소프트웨어를 위해 적용해야 할 디자인 원칙이다.

그러나 함수는 결코 유일한 스코프 단위가 아니다. 블록 스코프는 함수만이 아니라 (일반적으로 {} 같은) 임의의 코드 블록에 변수와 함수가 속하는 개념이다.

ES3부터 시작해서 try/catch 구조의 catch 부분은 블록 스코프를 가진다. ES6에서 키워드 let이 추가되어 임의의 코드 블록 안에 변수를 선언할 수 있게 됐다. "if () {let a= 2;}"에서 변수 a는 if 문의 {} 블록 스코프에 자신을 붙인다.

쉽게 착각하지만, 블록 스코프는 var 함수 스코프를 완전히 대체할 수 없다. 두 기능은 공존하며 개발자들은 함수 스코프와 블록 스코프 기술을 같이 사용할 수 있어야 하고 그래야 한다. 상황에 따라 더 읽기 쉽고 유지 보수가 쉬운 코드를 작성하기 위해 두 기술을 적절한 곳에 사용하면 된다.
