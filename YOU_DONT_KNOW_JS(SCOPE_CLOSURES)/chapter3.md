# 함수 vs 블록 스코프

* [3-1 함수 기반 스코프](#3-1-함수-기반-스코프)

## 3-1 함수 기반 스코프

각각의 선언된 함수는 저 마다의 버블을 생성하지만 다른 어떤 자료 구조도 자체적인 스코프를 생성하지 않는다. 뒤에서 살펴보겠지만, 이는 전혀 사실이 아니다. 먼저 함수 스코프와 그 암시적 용례를 살펴보자.

```js
function foo(a) {
  var b = 2;
  // some code
  function bar() {
    // ...
    // more code
    var c = 3;
  }
}
```

위의 코드에서 foo()의 스코프 버블을 확이면 a, b, c와 bar를 포함한다. 선언문이 스코프의 어디에 있는지는 중요하지 않다. 스코프 안에 있는 모든 변수와 함수는 그 스코프 버블에 속한다.

a, b, c, bar 모두 foo()의 스코프 버블에 속하므로 foo() 바깥에서는 이들에게 접근할 수 없다.

```js
bar(); // 실패
console.log( a, b, c) // 3가지 모두 실패
```

하지만 이 모든 확인자(a, b, c, foo, bar)는 foo() 안에서 접근할 수 있고, bar() 안에서도 이용할 수 있다(bar() 내부에서 섀도 확인자가 선언되지 않았을 때).

함수 스코프는 모든 변수가 함수에 속하고 함수 전체(심지어 중첩된 스코프에서도)에 걸쳐 사용되며 재사용된다는 개념을 확고하게 한다. 이런 디자인 접근버은 상당히 유용하고 자바스크립트 변수의 '동적' 특성을 완전히 살려 다른 타입의 값을 필요에 따라 가져올 수 있지만, 스코프 전체에서 변수가 살아있다는 점이 예상치 못한 문제를 일으킬 수도 있다.
