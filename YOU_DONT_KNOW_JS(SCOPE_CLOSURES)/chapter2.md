# 렉시컬 스코프

* [2-1 렉스타임](#2-1-렉스타임)
* [2-2 렉시컬 속이기](#2-2-렉시컬-속이기)
* [2-3 정리하기](#2-3-정리하기)

스코프는 두가지 방식으로 작동한다. 첫 번째 방식은 다른 방식보다 훨씬 더 일반적이고 다수의 프로그래밍 언어가 사용하는 방식이다. 이 방식을 렉시컬 스코프라고 부른다. 두번째 방식은 Bash Scripting이나 Perl의 일부 모드와 같은 몇몇 언어에서 사용하는 방식으로 동적 스코프라고 부른다.

## 2-1 렉스타임

렉시컬 스코프는 렉싱 타임에 정의되는 스코프다. 바꿔 말해 렉시컬 스코프는 프로그래머가 코드를 짤 때 변수와 스코프 블록을 어디서 작성하는가에 기초해서 렉서가 코드를 처리할 때 확정된다.

```js
////////////////////////////////////////////////////////////////
// 버블 1
function foo(a) { 
  /////////////////////////////////////////////////////////////
  // 버블 2 ( a 포함)
  var b = a * 2;
  function bar(c) {
    ///////////////////////////////////////////////////////////
    // 버블 3 ( c 포함)
    console.log( a, b, c );
    //////////////////////////////////////////////////////////
  }
  bar( b * 3);
  ////////////////////////////////////////////////////////////
}
foo( 2 ); // 2, 4, 12
///////////////////////////////////////////////////////////////
```

이 예제 코드에는 3개의 중첩 스코프가 있다.

* 버블 1은 글로벌 스코프를 감싸고 있고, 해당 스코프 안에는 오직 하나의 확인자(foo)만 있다.
* 버블 2는 foo의 스코프를 감싸고 있고, 해당 스코프는 3개의 확인자(a, bar, b)를 포함한다.
* 버블 3은 bar의 스코프를 감싸고 있고, 해당 스코프는 하나의 확인자(c)만을 포함한다.

스코프 버블은 스코프 블록이 쓰이는 곳에 따라 결정되는데, 스코프 블록은 서로 중첩될 수 있다. 지금은 각각의 함수가 새로운 스코프 버블을 생성한다고 가정하자.

bar의 버블은 foo의 버블 내부에 완전히 포함된다. 바로 foo의 내부에서 bar 함수를 정의했기 때문이다.

어떤 함수의 버블도 동시에 (일부라도) 다른 두 스코프 버블 안에 존재할 수 없다. 어떤 함수도 두 개의 부모 함수 안에 존재할 수 없는 것처럼 말이다.

### 2-1-1 검색

엔진은 스코프 버블의 구조와 상대적 위치를 통해 어디를 검색해야 확인자를 찾을 수 있는지 안다.

앞의 코드를 보면 엔진은 console.log() 구문을 실행하고 3개의 참조된 변수 a, b, c를 검색한다. 검색은 가장 안쪽의 스코프 버블인 bar() 함수의 스코프에서 시작한다. 여기서 a를 찾지 못하면 다음으로 가장 가까운 스코프 버블인 foo()의 스코프로 한 단계 올라가고, 이곳에서 a를 찾아 사용한다. 똑같은 방식이 b에도 적용된다. 단 c는 bar() 내부에서 찾을 수 있다.

변수 c가 bar()와 foo() 내부에 모두 존재한다고 가정하면, console.log() 구문은 bar() 내부에 있는 c를 찾아서 사용하고 foo()에는 c를 찾으러 가지도 않는다.

스코프는 목표와 일치하는 대상을 찾는 즉시 검색을 중단한다. 여러 중첩 스코프 층에 걸쳐 같은 확인자 이름을 정의할 수 있다. 이를 'shadowing'이라 한다.(더 안쪽의 확인자가 더 바깥쪽의 확인자를 가리키는 것이다) shadowing과 상관없이 스코프 검색은 항상 실행 시점에서 가장 안쪽 스코프에서 시작하여 최초 목표와 일치하는 대상을 찾으면 멈추고, 그전까지는 바깥/위로 올라가면서 수행한다.

NOTE: 글로벌 변수는 자동으로 웹 브라우저의 window 같은 글로벌 객체에 속한다. 따라서 글로벌 변수르 ㄹ직접 렉시컬 이름으로 참조하는 것뿐만 아니라 글로벌 객체의 속성을 참조해 간접적으로 참조할 수도 있다.(예를 들어 window.a) 그러나 글로벌이 아닌 shadow 변수는 접근할 수 없다.

어떤 함수가 어디서 또는 어떻게 호출되는지에 상관없이 함수의 렉시컬 스코프는 함수가 선언된 위치에 따라 정의된다.

렉시컬 스코프 검색 과정은 a, b, c와 같은 일차 확인자 검색에만 적용된다. 코드에서 foo.bar.baz의 참조를 찾는다고 하면 렉시컬 스코프 검색은 foo 확인자를 찾는데 사용되지만, 일단 foo를 찾고 나서는 객체 속성 접근 규칙을 통해서 bar와 baz의 속성을 각각 가져온다.

## 2-2 렉시컬 속이기

자바스크립트에서는 렉시컬 스코프를 속일 수 있는 두 가지 방법이 있다. 권자하지 않는 방법이고 렉시컬 스코프를 속이는 방법은 성능을 떨어뜨린다.

### 2-2-1 eval

eval() 함수는 문자열을 인자로 받아들여 실행 시점에 문자열의 내용을 코드의 일부분처럼 처리한다. 즉, 처음 작성한 코드에 프로그램에서 생성한 코드를 집어넣어 마치 처음 작성될 때부터 있던 것처럼 실행한다.

```js
function foo(str , a){
  eval( str ); // cheating => var b = 3;
  console.log( a, b );
}

var b = 2;
foo ( "var b = 3;", 1); // 1, 3
```

이 코드는 실제로 foo() 안에 변수 b를 생성하여 바깥(글로벌) 스코프에 선언된 변수 b를 가린다. 그래서 바깥의 b를 찾지 않기 때문에 "1, 3"이 나온다.

기본적으로 코드 문자열이 하나 이상의 변수 또는 함수 선언문을 포함하면 eval()이 그 코드를 실행하면서 eval()이 호출된 위치에 있는 렉시컬 스코프를 수정한다. 즉, eval()은 프로그래머가 작성했던 때의 렉시컬 스코프를 런타임에서 수정할 수 있다.

NOTE: Strict Mode 프로그램에서 eval()을 사용하면 eval()은 자체적인 렉시컬 스코프를 이용한다. 즉, eval() 내에서 실행된 선언문은 현재 위치의 스코프를 실제로 수정하지 않는다.

자바스크립트에는 eval()과 매우 비슷한 효과를 내는 다른 방법이 있다. setTimeout()과 setInterval()은 첫째 인자로 문자열을 받을 수 있고, 문자열의 내용은 동적 생성된 함수 코드처럼 처리된다. 이 방법은 구식에다가 없어질 예정이니 사용하지 말자!

함수 생성자 new Function()도 비슷한 방식으로 코드 문자열을 마지막 인자로 받아서 동적으로 생성된 함수로 바꾼다(입력받은 시작 인자들이 있으면 생성된 함수의 인자로 사용된다). 이 함수 생성자 문법은 eval()보다는 좀 더 안전하지만, 여전히 코드에 사용하지 않는 것이 좋다.

동적으로 생성한 코드를 프로그램에서 사용하는 경우는 괴장히 드문데, 사용할 때 성능 저하를 감수할 만큼 활용도가 높지 않기 때문이다.

### 2-2-2 with

키워드 with는 렉시컬 스코프를 속일 수 있는 자바스크립트의 또 다른 기능이다(하지만 사용을 권장하지 않는다. 이 기능은 곧 없어질 예정이다). 필자는 with가 렉시컬 스코프와 어떻게 상호착용하고 스코프에 어떤 영향을 주느냐는 관점에서 설명하고자 한다.

with는 일반적으로 한 객체의 여러 속성을 참조할 때 객체 참조를 매번 반복하지 않기 위해 사용하는 일종의 속기법이라 할 수 있다.

```js
var obj = {
  a: 1,
  b: 2,
  c: 3
};

// more "tedious" to repeat "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;

// "easier" short-hand
with (obj) {
  a = 3;
  b = 4;
  c = 5;
}
```

with는 단순히 객체 속성을 편하게 접근할 수 있는 속기법 이상의 효과가 있다.

```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

var o1 = {
  a: 3
};

var o2 = {
  b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); //undefined
console.log(a); // 2 헉! leaked gloabal!
```

eval()은 인자로 받은 코드 문자열에 하나 이상의 선언문이 있을 경우 이미 존재하는 렉시컬 스코프를 수정할 수 있지만, with 문은 넘겨진 객체를 가지고 난데없이 사실상 하나의 새로운 렉시컬 스코프를 생성한다.

이렇게 볼 때, o1을 넘겨받은 with 문은 o1이라는 스코프를 선언하고 그 스코프는 o1.a 속성에 해당하는 확인자를 가진다. 그러나 o2가 스코프로 사용되면 그 스코프에는 a 확인자가 없으므로 이후 작업은 일반적인 LHS 확인자 검색 규칙(1장 참조)에 따라 진행된다.

o2의 스코프, foo()의 스코프, 글로벌 스코프에서도 a 확인자는 찾을 수 없다. 따라서 "a = 2"가 수행되면 자동으로 그에 해당하는 글로벌 변수가 생성된다(non-Strict Mode).

### 2-2-3 성능

자바스크립트 엔진은 컴파일레이션 단계에서 상당수의 최적화 작업을 진행한다. 이 최적화의 일부분이 하는 핵심 작업은 렉싱된 코드를 분석하여 모든 변수와 함수 선언문이 어디에 있는지 파악하고 실행 과정에서 확인자 검색을 더 빠르게 하는 것이다.

그러나 eval()이나 with가 코드에 있다면 엔진은 미리 확인해둔 확인자의 위치가 틀릴 수도 있다고 가정해야 한다. 엔진은 렉싱 타임일 때 eval()에 어떤 코드가 전달되어 렉시컬 스코프가 수정될지 정확하게 알 수 없고, with에 넘긴 객체의 내용에 따라 새로운 렉시컬 스코프가 생성될 수 있기 때문이다. 즉, eval()이나 with가 코드에 있다면 대다수 최적화가 의미 없어져서 아무런 최적화도 하지 않은 것이나 마찬가지가 되어 버린다.

따라서 단순히 코드 어딘가에서 eval()이나 with를 사용했다는 사실 하나만으로 그 코드는 거의 확실히 더 느리게 동작할 것이다.

## 2-3 정리하기

렉시컬 스코프란 프로그래머가 코드를 작성할 때 함수를 어디에 선언하는지에 따라 정의되는 스코프를 말한다. 컴파일레이션의 렉싱 단계에서는 모든 확인자가 어디서 어떻게 선언됐는지 파악하여 실행 단계에서 어떻게 확인자를 검색할지 예상할 수 있도록 도와준다.

자바스크립트에는 렉시컬 스코프를 속이는 두 가지 방식이 있는데, eval()과 with다. eval()은 하나 이상의 선언문을 포함하는 코드 문자열을 해석하여 렉시컬 스코프가 있다면 런타임에 이를 수정한다. with는 객체 참조를 하나의 스코프로, 속성을 확인자로 간주하여 런타임에 완전히 새로운 렉시컬 스코프를 생성한다.

이런 방식의 단점은 eval()과 with가 엔진이 컴파일 단계에서 수행한 스코프 검색과 관련된 최적화 작업을 무산시킨다는 점이다. 이들이 수행되면 엔진은 최악의 경우를 대비해 진행했던 최적화 결과가 무효화됐다고 가정해야 하기 때문이다. 따라서 eval()과 with 중 하나라도 사용하면 코드는 더 느리게 동작하므로 이 방식은 사용하지 말자.
