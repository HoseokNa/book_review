# 호이스팅

* [4-1 닭이 먼저냐 달걀이 먼저냐](#4-1-닭이-먼저냐-달걀이-먼저냐)
* [4-2 컴파일러는 두 번 공격한다](#4-2-컴파일러는-두-번-공격한다)
* [4-3 함수가 먼저다](#4-3-함수가-먼저다)
* [4-4 정리하기](#4-4-정리하기)

선언문이 스코프의 어디에 있는지에 따라 스코프에 변수가 추가되는 과정에 미묘한 차이가 있다. 여기서 그 차이에 대해 살펴보자.

## 4-1 닭이 먼저냐 달걀이 먼저냐

```js
a = 2;
var a;
console.log(a);
```

undefined를 가질 것이라 추측하겠지만 결과는 2다.

```js
console.log(a);
var a = 2;
```

전과 같이 2 혹은 a가 선언되기 전에 사용되었으니 ReferenceError가 발생한다고 생각할 수 있다.

불행히도 둘 다 틀렸다. 출력 결과는 undefined다.

왜 그럴까? 선언문이 먼저일가 아니면 대입문이 먼저일까?

## 4-2 컴파일러는 두 번 공격한다

자바스크립트 엔진이 코드를 인터프리팅하기 전에 컴파일한다는 사실을 기억해보자. 컴파일레이션 단계 중에는 모든 선언문을 차자 적절한 스코프에 연결해주는 과정이 있었다. 2장에서는 바로 이 과정이 렉시컬 스코프의 핵심이라고 배웠다.

자, 이제 변수와 함수 선언문 모두 코드가 실제 실행되기 전에 먼저 처리된다고 보면 된다. 어쩌면 "var a = 2;"를 하나의 구문이라고 생각할 수 있다. 그러나 자바스크립트는 다음 두 개의 구문으로 본다.

* var a;
* a = 2;

첫째 구문은 선언문으로 컴파일레이션 단계에서 처리된다. 둘째 구문은 대입문으로 실행 단계까지 내버려둔다. 따라서 첫 번째 코드 조각은 다음과 같이 처리된다.

```js
var a;
a = 2;
console.log(a);
```

첫째 부분은 컴파일레이션 과정이고, 둘째 부분은 실행 과정이다.

두 번째 코드 조각은 다음과 같이 처리 된다.

```js
var a;
console.log(a);
a = 2;
```

이 과정을 비유적으로 말하면 변수와 함수 선언문은 선언된 위치에서 코드의 꼭대기로 '끌어올려' 진다. 이렇게 선언문을 끌어올리는 동작을 "호이스팅(Hoisting)"이라고 한다. 즉, 달걀(선언문)이 닭(대입문)보다 먼저다.

NOTE: 선언문만 끌어올려지고 다른 대입문이나 실행 로직 부분은 제자리에 그대로 둔다. 호이스팅으로 코드 실행 로직 부분이 재배치 된다면 큰 혼란이 생길 수 있다.

```js
foo();

function foo() {
  console.log(a); //undefined
  var a = 2;
}
```

함수 foo의 선언문(앞의 예에서 실제 함수의 값은 포함한다)은 끌어올려줬으므로 foo를 첫째 줄에서도 호출 할 수 있다.

호이스팅이 스코프별로 작동한다는 점도 중요하다. 앞에서는 오직 글로벌 스코프만 포함된 단순한 상황을 예로 들었지만, 예제의 함수 foo() 내에서도 변수 a가 (프로그램의 꼭대기가 아니라) foo()의 꼭대기기로 끌어올려진다. 예제 코드에 호이스팅을 적용해 좀 더 정확히 해석하면 다음과 같다.

```js
function foo() {
  var a;
  console.log(a); //undefined
  a = 2;
}

foo();
```

함수 선언문은 이와 같이 끌어올려지지만 함수 표현식은 다르다.

```js
foo();  // ReferenceError가 아니라 TypeError!

var foo = function bar () {
  // ...
};
```

변수 확인자 foo는 끌어올려져 둘러싼 (글로벌) 스코프에 붙으므로 foo() 호출은 실패하지 않고, ReferenceError도 발생하지 않는다. 그러나 foo는 아직 값을 가지고 있지 않는데(마치 foo가 함수 표현식이 아니라 진짜 선언문으로 생성된 것처럼), foo()가 undefined 값을 호출하려해서 TypeError라는 오작동을 발생시킨다.

또 기억할 것은 함수 표현식이 이름을 가져도 그 이름 확인자는 해당 스코프에서 찾을 수 없다는 점이다.

```js
foo();  // TypeError
bar();  // ReferenceError

var foo = function bar () {
  // ...
};
```

이 코드에 호이스팅을 적용하면 다음과 같다.

```js
var foo;

foo();  // TypeError
bar();  // ReferenceError

foo = function () {
  var bar = ...self...
  // ...
};
```

## 4-3 함수가 먼저다

함수와 변수 선언문은 모두 끌어올려진다. 그러나 미묘한 차이가 있는데, 먼저 함수가 끌어올려지고 다음으로 변수가 올려진다.

```js
foo();  // 1
var foo;

function foo() {
  console.log(1);
}

foo = function() {
  console.log(2);
};
```

결괏값으로 2가 아니라 1이 출력된다! 엔진은 이 코드를 다음과 같이 해석한다.

```js
function foo() {
  console.log(1);
}

foo();  // 1

foo = function() {
  console.log(2);
};
```

var foo가 중복 (그래서 무시된) 선언문이라는 점을 보자. var foo는 function foo() 선언문보다 앞서 선언됐지만, 함수 선언문이 일반 변수 위로 끌어올려졌다. 많은 중복 변수 선언문이 사실상 무시됐지만 중복 함수 선언문은 앞선 것들을 겹쳐 쓴다.

```js
foo();  // 3

function foo() {
  console.log(1);
}

var foo = function() {
  console.log(2);
};

function foo() {
  console.log(3);
}
```

같은 스코프 내에서의 중복 정의가 얼마나 나쁜 방식이고 혼란스러운 결과를 내는지 잘 알 수 있다. 일반 블록 안에서 보이는 함수 선언문은 보통 둘러싼 스코프로 끌어올려지지만, 다음 코드가 보여주듯 따르지 않을 수 도 있다.

```js
foo();  // "b

var a = true;
if (a) {
  function foo() {
    console.log("a");
  }
}
else {
  function foo() {
    console.log("b");
  }
}
```

블록 내 함수 선언은 지양하는 것이 가장 좋다.

## 4-4 정리하기

"var a = 2;"는 하나의 구문처럼 보이지만, 자바스크립트 엔진은 그렇게 보지 않는다. 엔진은 이를 "var a"와 "a = 2"라는 두 개의 독립된 구문으로 보고, 첫째 구문은 컴파일러 단계에서 처리하고 둘째 구문은 실행 단계에서 처리한다.

이것이 의미하는 바는 스코프의 모든 선언문은 어디서 나타나든 실행 전에 먼저 처리된다는 점이다. '호이스팅'이라 불리는 이 과정은 (변수와 함수) 선언문 각각이 속한 스코프의 꼭대기로 '끌어올려' 지는 작업이라고 생각할 수 있다. 그 과정에서 선언문 자체는 옮겨지지만, 함수 표현식의 대입문을 포함한 모든 대입문은 끌어올려 지지 않는다.

중복 선언을 조심하자. 일반 변수 선언과 함수 선언을 섞어 사용하면 특히 더 위험하다!
