# 1장 좋은 소프트웨어 만들기

* [1-1 바르게 시작하는 코드 작성하기](#1-1-바르게-시작하는-코드-작성하기)

## 1-1 바르게 시작하는 코드 작성하기

### 1-1-1 자바스크립트 특성을 완벽히 섭렵하라

#### 자바스크립트는 싱글 스레드로 움직인다.

자바스크립트는 어떤 이벤트가 끝나자마자 실행할 함수를 큐에 넣는 게 고작이다. 여기서 이벤트란 일정 시간 경과(setTimeout), 다른 웹 사이트에서 데이터 조회(XMLHttpRequest.send), 마우스 클릭 등이다. 자바스크립트 엔진은 이벤트 루프에서 한 번에 하나씩 함수를 꺼내 실행한다.

설계 관점에서 보면 제어권을 가진 상태에서 인터럽트를 당하거나 다른 객체가 변수에 마음대로 접근하는 식의 문제는 신경 쓰지 않아도 되니까 편하다. 또한, 프로세서를 독차지할 염려도 없다.

### 1-1-2 대규모 시스템에서 자바스크립트 함정을 피하라

클라이언트/서버 양쪽에서 규모가 큰 시스템의 부하를 감당할 수 있게 해주는 SPA, 노드JS 같은 자바스크립트 기술이 등장하면서 개발자는 통신 채널을 최소화하는 문제를 진지하게 고민하게 되었다.

본연의 임무를 수행하기 위해 객체 간 인터페이스가 불가피하다면 어떤 상황에서도 모든 객체가 올바르게 작동하게끔 지속해서 연결을 관리해야 한다.

#### 스크립트는 모듈이 아니다

한 페이지에 스크립트가 하나밖에 없던 시절에는 전역 네임스페이스에 함수를 추가해도 별 탈이 없었다. 요즘 자바스크립트 애플리케이션에서는 어림도 없는 소리다.

자바스크립트는 데이터와 함수를 적절히 캡슐화한 모듈을 만드는 조리법이 매우 다양하다. 스크립트 파일은 그런 조리법이 아니다.(데이터 캡슐화는 4장에서 자세히 다룬다)

#### 스코프는 중첩 함수로 다스린다.

C# / 자바는 클래스 안에 다른 클래스를 둘 수 있다. 물론 자주 쓰는 기법은 아니다. 심지어 마이크로소프트사는 "중첩된 타입은 캄춰야 한다(CA10304)"라는 경고까지 했다.

자바스크립트는 함수를 중첩하여 코드를 계층화할 수 있다. 덕분에 개발자가 원하는 것을 찾는데 도움이 될 뿐만 아니라 프로그램에서 변수/함수의 스코프를 최소화할 수 있다. 바로 이러한 특성이 대규모 시스템을 효과적으로 유지하는 핵심이자 자바스크립트 코등의 탁월한 근본 요소다.

#### 규악을 지켜 코딩한다.

대규모 시스템을 잘 꾸려 나가려면 될 수 있는 한 작게 만들어야 효과적이다. 자바스크립트는 간이 고루 잘 밴 덕 타이핑의 기상천외한 유연성 덕분에 적은 코드로도 많은 일을 할 수 있다.

반면에, 자신이 짠 프로그램에 누가 무엇을 던져 넣을지 도통 알 수가 없다.

함수 인자에 특정한 조건이 있다면 그 값을 꼭 검증해야 한다. 16 ~ 21 장에서는 규약 레지스트리를 이야기한다.

레지스트리는 한 마디로 함수에 따로 코딩을 안해도 인자 또는 반환값을 확인할 수 있게 해주는 장치다. 애스팩트 지향 프로그래밍(2장의 주제)이라는 마술과 더불어 배포 버전의 검증 오버헤드를 줄인다.

### 1-1-3 소프트웨어 공학 원칙을 적용하라

이 절에서 말한 원칙을 섭렵할 즈음, 힘을 덜 들이고 더 신속하게, 빈틈없이 완벽한 소프트웨어를 작성할 수 있을 것이다.

#### SOLID 원칙

* *S* ingle Responsibility Principle(단일 책임 원칙)
* *O* pen/Closed Principle(개방/폐쇄 원칙)
* *L* iskov Substitution Principle(리스코프 치환 원칙)
* *I* nterface Segregation Principle(인터페이스 분리 원칙)
* *D* ependency Inversion Principle(의존성 역전 원칙)

#### 단일 책임 원칙

다소 과장해서 말하면 모든 클래스(자바스크립트는 함수)는 반드시 한 가지 변경 사유가 있어야 한다.

정말 무리한 요건이다. 그럼 함수를 모조리 코드 한 줄만으로 작성하라는 말인가?

예제의 rj3.svg.line 함수는 어떤 형태의 데이터 소스라도 입력받하 SVG 라인 경로를 생성할 수 있다. 여기서 만약 데이터가 바뀌면? 이 함수는 단서가 될 만한 정보는 사실상 외부에서 다 받고 점 데이터에서 x, y 좌푯값을 추출하는 방법까지 넘겨 받는다. 정작 rj3.svg.line은 '아는'게 없다. 그저 점 데이터를 배열로 받아 SVG 경로를 그려주는 함수(내부 line)를 반환할 뿐이다.

rjs3.svg.line을 변경할 일이 과연 있을까? 이 함수의 유일한 관심사는 배열에서 SVG 경로를 만드는 일이다. 이 관심사를 어떠헥 이행할지는 철저하게 외부에서 제공한 함수에 달려 있으니 변경 할 이유가 전혀 없다.

#### 개방.폐쇄 원칙

"모든 소프트웨어 개체는 확장 가능성은 열어 두되 수정 가능성은 닫아야 한다"는 원칙이다.

즉, 어떤 경우라도 실행 코드를 변경하지 말고, 어떻게든 (상속 등의 방법으로) 재사용하고 확장하라는 뜻이다.

로버트 마틴조차도 이런 말을 남겼다. "일반적으로 완벽한 닫힘은 있을 수 없으니 모종의 전략이 필요합니다. 다시 말해서 설계장는 불가피한 변경 유형을 미리 선택할 수밖에 없습니다. 오랜 경험에서 비롯된 통찰력이 필요한 부분입니다."

d3.svg.line 함수를 설계할 때 마이크 보스톡은 데이터에서 좌푯값을 뽑아내는 방법과 점을 연결하는(보간하는) 방법에 변경 사항이 있으리라 내다보고 이러한 특성을 추상화하여 함수 밖으로 빼내는 기지를 발휘했다.

그가 변경되지 않을 거라고(적어도 이전 버전과 호환되지 않는 식으로 바뀌지 않을 거라) 본 건 SVG 경로의 규격이다. 반드시 "M"으로 시작해서 그 뒤에 점 데이터가 이어지는 문자열 형태로 과감히 경로 문자열을 하드 코딩한 것이다.

SVG 명세서가 하루아침에 바뀔 일은 없을 테니 d3.svg.line 역시 손댈 일은 거의 없을 것이다.

#### 리스코프 치환 원칙

리스코프 치환 원칙을 자바스크립트에서 흔한 표현으로 바꾸면 다음과 같다.

> 어떤 타입에서 파생된 타입의 객체가 있다면 이 타입을 사용하는 코드는 변경하지 말아야 한다.

다시 말해, 한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되어서는 안 된다는 뜻이다. 여러분이 작성 중인 함수가 기반 클래스로 하는 일과 서브 클래스로 하는 일이 다르다면 이 원칙을 어긴 셈이다.

서로 파생 관계가 없는 타입 간에는 적용되지 않는다. 예컨데 자바스크립트에서는 어떤 함수의 인자가 숫가일 때, 문자열일 때, 아예 인자가 업슨 undefined 타입일 때를 각각 분기 처리하는 것이 대게 좋은 습관이다.

덕 타이핑 역시 파생과는 조금 다르지만, 이 원칙과 잘 들어 맞는다.

#### 인터페이스 분리 원칙

이 원칙은 C++, 자바 같은 인터페이스 기반 언어 환경에서 비롯되었다. 이들 언어에서 인터페이스란 클래스에서 어떤 기능을 '구현'하지 않고(명칭, 파라미터, 반환 타입을) '서술'만 한 코드 조각이다.

기능이 많은 인터페이스는 더 작게 응축시킨 조각으로 나누어야 한다는 발상이다. 인터페이스 사용부는 '뚱뚱한' 전체가 아니라 아주 작은 인터페이스 하나만 바라보면 된다.

물론 모듈 간 연결 폭을 최소화하는 방향으로 가야 한다.

자바스크립트에서 이 원칙을 어떻게 실현하는지는 16장에 나와 있다.

인터페이스 분리 원칙의 정신을 실현하려면 함수가 기대하는 인자가 무엇인지 명확히 하고 그 기대치를 최소화해야 한다. 이럴 때도 덕 타이핑이 도움된다. 특정 타입의 인자를 바라기보다는 이 타입에서 실제로 필요한 프로퍼티가 더러 있을 거라 기대하는 것이다.

#### 의존성 역전 원칙

이 원칙도 인터페이스와 관련 있다. 로버트 마틴은 "상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며 이 둘은 추상화에 의존해야 한다".라고 말했다.

인터페이스 기반 언어에서는 대개 의존성 주입이라는 연관된 개념으로 표현한다. 클래스 A가 클래스 B의 서비스가 필요할 때 A는 B를 생성하지 않는다. 대신 A 생성자에 건넨 파라미터 하나가 B를 서술하는 인터페이스 역할을 한다. 이제 A는 B에 의존하지 않고 자신의 인터페이스만 바라본다. A가 생성되면 구체화한 B를 넘겨 받는다. B 역시 인터페이스에 의존한다.

리스코프 치환 원칙 덕분에 인터페이스를 만족하는, B의 파생형 버전을 제공할 수 있는 이점이 있다. 또한, 인터페이스는 (개방/폐쇄 원칙에도 불구하고) B를 고쳐야 할 경우 하위 버전 호환성을 유지하려면 어떤 로직을 계속 갖고 있어야 하는지 일목요연하게 서술한다.

#### DRY 원칙

"Don't Repeat Yourself"라는 말 역시 좋은 소프트웨어 개발 습관의 근원이다. "모든 지식 조각은 딱 한 번만 나와야 한다"라는 말이다.

먼저, 가장 중요한 SOLID의 원칙 중 일부가 DRY 원칙의 필연적 산물이다.

단일 책임 원칙이 그렇다. 이 원칙을 어긴 코든느 결과적으로 다시 쓸 수 없다. X와 Y를 함께 하는 모듈이 있다. X를 하는 코드가 필요할 때 Y 로직을 들어내지 않는 한 모듈을 재사요할 수 없으므로 또 다시 X를 코딩할 수밖에 없다. DRY 원칙과 맞지 않다.

X와 Y를 하는 함수 2개를 모듈에 주입해서 하나의 책임으로 묶어두면 문제를 해결할 수 있다. DRY한 코드로 만드는 과정에 의존성 주입과 단일 책임 문제가 개입된다.

DRY함은 여타 언어와 비교했을 때 자바스크립트에서 특별히 중요하다. 자바스크립트는 잘못 코딩한 특정 클래스를 컴파일러가 미리 알려주지 않으니 자칫 그대로 운영 환경에 노출될 가능성이 크다. 참사를 예방하려면 될 수 있는 대로 빨리 실수를 인지하는게 상책이다.

## 1-2 바르게 유지되는 코드 작성하기

### 1-2-1 단위 테스트는 미래에 대비한 투자다

단위 테스트(unit test)는 시간이 흐르면서 아무리 큰 변화의 소용돌이 속에 빠져도 완벽한 프로그램을 만들 수 있게 한다.

단위 테스트 본체에 작성한 코드는 준비(arrange), 실행(act), 단언(assert)의 패턴을 따른다.

첫째, 테스트 **준비**다. 단위를 실행할 조건을 확실히 정하고, 의존성 및 함수 입력 데이터를 설정한다.

둘째, 단위를 **실행**하여 테스트 한다. 예를 들어 단위가 함수면 준비 단계에서 미리 설정한 입력값을 함수에 넘겨 실행한다.

마지막은 테스트 **단언**이다. 미리 정한 조건에 따라 예상대로 단위가 작동하는지 확인한다. 단위가 함수인 테스트라면 예상한 값을 반환하는지 조사하면 된다.

단위 테스트가 실패한다는 것은 어떤 변화로 인해 기존 프로그램의 기능이 바뀌었으니 실패를 유발한 이 변화를 자세히 들여보아야 한다는 사실을 일깨워준다.

### 1-2-2 테스트 주도 개발을 실천하라

테스트 주도 개발(Test-Driven Development, TDD)은 처음부터 프로그램을 제대로 작성했는지 확실히 보장한다. TDD에서는 애플리케이션 코드를 짜기 '전에' 이 코드가 통과해야 할 단위 테스트를 '먼저' 작성한다. 마치 애플리케이션을 개발하듯 전체 단위 테스트 꾸러미를 만들어가는 TDD 방식을 따르면 단위 정의와 인터페이스 설계에 도움이 많이 된다.

TDD를 실천하는 개발자는 애플리케이션에 어떤 변화가 생길 때마다 다음 단계를 밟는다.

1. 완벽히 변경하면 성공하나 그렇게 되기 전까지는 반드시 실패하는 단위 테스트를 작성한다.
2. 테스트가 성공할 수 있을 만큼만 '최소한으로' 코딩한다.
3. 애플리케이션 코드를 리팩토링하며 중복을 제거한다.

이 세 단계를 흔히 **적색**(red), **녹색**(green), **리팩터**(refactor)라고 줄여 말한다. 적색은 실패, 녹색은 성공 상태를 가리킨다.

TDD에서 가장 중요한건 테스트를 충족할 코드를 만들기 전에 테스트를 먼저 작성한다는 사실이다.

애플리케이션을 바르게 개발하려는 의지가 있다면 테스트를 건너뛰고 싶은 욕망을 극복해야 한다.

애플리케이션 코드를 바꾸고 나서 테스트를 작성하면 되지 않나 싶을 수도 있다. 이렇게 만든 새 테스트는 잘못된 테스트라도 무사 통과할 가능성이 있다. 또한 코드가 작성한 대로 작동할 거라는 뚱딴지 같은 사실을 확인하는 꼴이 된다.

## 1-2-3 테스트하기 쉬운 코드로 다듬어라

테스트하기 쉬운 코드를 작성하려면 가장 중요한 단계는 관심사를 적절히 분리하는 일이다.

서로 다른 관심사는 작고 간단한 모듈로 나누어 만들면 코드 작성과 테스트, 그리고 이해가 쉽다. 이런 식으로 만든 코드는 장기적으로 별 탈 없이 작동할 가능성이 크다.

무수한 실수의 늪에 빠져 허우적거리기 전에 단위 테스트가 실수를 가능한 한 빨리 발견하는 길이라는 진리를 기억하라.

적색-녹색-리팩터 과정을 반복하며 작은 코드를 개발하다 보면 점점 속도가 붙게 된다. 음악 연주자가 처음엔 느리고 조심스럽게 연습하다가 점점 연주곡을 더 빨리 마스터하게 되는 것과 같은 이치다.

첫째, 작은 코드는 대개 간단하고 실수할 가능성이 작아 디버깅 시간을 상당히 줄일 수 있다.
둘째, 테스트로 코드를 완전히 커버하니 리팩토링을 하더라도 무서울 게 없다. 따라서 코드를 DRY하게 유지하여 코드베이스에 오류 발생 여지를 줄이고 규모를 작게 가져갈 수 있다. DRY는 결국 재사용을 의미하며 알다시피 재사용 가능한 코드는 시간을 절약한다.

## 1-3 정리하기

자바스크립튼느 개발자에게 훌륭한 걸계 기회다. rj3.svg.line은 아주 작은 함수지만 함수의 객체성(자바스크립트에서 함수는 객체다), 중첩 함수, 함수 오버로딩, 덕 타이핑, 클로저, this의 강력함을 잘 보여준다.

자바스크립트의 사용 범위가 대규모 시스템으로 확대되면서 언어 자체의 거친 부분을 잘 다루는 일이 아주 중요해졌다. 개별 스크립트 파일로 코드를 나누는 것이 어떤 면에서는 좋은 생각이지만, 진정한 모듈화는 아니라는 사실을 이야기 했다. 검증된 소프트웨어 공학 이론과 D3 사례로 예시한 설계 기회에 기반을 두라. 다섯 가지 SOLID 원칙과 DRY 원칙을 소개했다.

단위 테스트는 장기적인 관점에서 안정된 애플리케이션을 만들기 위한 최선의 투자다. 단위 테스트가 없으면 그저 애플리케이션이 잘 작동하기를 막연히 기도할 수밖에 없다.

테스트 주도 개발을 실천하면 여러 가지 혜택이 있다. 첫째, 장기적인 믿음성을 보장하는 단위 테스트 꾸러미를 구축한다. 둘째, 애플리케이션 객체에 정확한 인터페이스를 설계할 때 도움이 된다. 셋째, 놀랍게도 단위 테스트를 통해 코드를 더 빨리 개발할 수 있다.

테스트성을 높이려면 관심사를 분리하는 일에 집중하고 단일 책임 원칙이나 의존성 주입 같은 소프트웨어 공학 원칙을 잘 써먹는 게 중요하다.

이런 아이디어로 무장해야만 비로소 소프트웨어 장인이 될 준비를 마칠 수 있다. 이제 도구를 꺼내어볼 시간이다.