# 1장 좋은 소프트웨어 만들기

* [1-1 바르게 시작하는 코드 작성하기](#1-1-바르게-시작하는-코드-작성하기)

## 1-1 바르게 시작하는 코드 작성하기

### 1-1-1 자바스크립트 특성을 완벽히 섭렵하라

#### 자바스크립트는 싱글 스레드로 움직인다.

자바스크립트는 어떤 이벤트가 끝나자마자 실행할 함수를 큐에 넣는 게 고작이다. 여기서 이벤트란 일정 시간 경과(setTimeout), 다른 웹 사이트에서 데이터 조회(XMLHttpRequest.send), 마우스 클릭 등이다. 자바스크립트 엔진은 이벤트 루프에서 한 번에 하나씩 함수를 꺼내 실행한다.

설계 관점에서 보면 제어권을 가진 상태에서 인터럽트를 당하거나 다른 객체가 변수에 마음대로 접근하는 식의 문제는 신경 쓰지 않아도 되니까 편하다. 또한, 프로세서를 독차지할 염려도 없다.

### 1-1-2 대규모 시스템에서 자바스크립트 함정을 피하라

클라이언트/서버 양쪽에서 규모가 큰 시스템의 부하를 감당할 수 있게 해주는 SPA, 노드JS 같은 자바스크립트 기술이 등장하면서 개발자는 통신 채널을 최소화하는 문제를 진지하게 고민하게 되었다.

본연의 임무를 수행하기 위해 객체 간 인터페이스가 불가피하다면 어떤 상황에서도 모든 객체가 올바르게 작동하게끔 지속해서 연결을 관리해야 한다.

#### 스크립트는 모듈이 아니다

한 페이지에 스크립트가 하나밖에 없던 시절에는 전역 네임스페이스에 함수를 추가해도 별 탈이 없었다. 요즘 자바스크립트 애플리케이션에서는 어림도 없는 소리다.

자바스크립트는 데이터와 함수를 적절히 캡슐화한 모듈을 만드는 조리법이 매우 다양하다. 스크립트 파일은 그런 조리법이 아니다.(데이터 캡슐화는 4장에서 자세히 다룬다)

#### 스코프는 중첩 함수로 다스린다.

C# / 자바는 클래스 안에 다른 클래스를 둘 수 있다. 물론 자주 쓰는 기법은 아니다. 심지어 마이크로소프트사는 "중첩된 타입은 캄춰야 한다(CA10304)"라는 경고까지 했다.

자바스크립트는 함수를 중첩하여 코드를 계층화할 수 있다. 덕분에 개발자가 원하는 것을 찾는데 도움이 될 뿐만 아니라 프로그램에서 변수/함수의 스코프를 최소화할 수 있다. 바로 이러한 특성이 대규모 시스템을 효과적으로 유지하는 핵심이자 자바스크립트 코등의 탁월한 근본 요소다.

#### 규악을 지켜 코딩한다.

대규모 시스템을 잘 꾸려 나가려면 될 수 있는 한 작게 만들어야 효과적이다. 자바스크립트는 간이 고루 잘 밴 덕 타이핑의 기상천외한 유연성 덕분에 적은 코드로도 많은 일을 할 수 있다.

반면에, 자신이 짠 프로그램에 누가 무엇을 던져 넣을지 도통 알 수가 없다.

함수 인자에 특정한 조건이 있다면 그 값을 꼭 검증해야 한다. 16 ~ 21 장에서는 규약 레지스트리를 이야기한다.

레지스트리는 한 마디로 함수에 따로 코딩을 안해도 인자 또는 반환값을 확인할 수 있게 해주는 장치다. 애스팩트 지향 프로그래밍(2장의 주제)이라는 마술과 더불어 배포 버전의 검증 오버헤드를 줄인다.

### 1-1-3 소프트웨어 공학 원칙을 적용하라

이 절에서 말한 원칙을 섭렵할 즈음, 힘을 덜 들이고 더 신속하게, 빈틈없이 완벽한 소프트웨어를 작성할 수 있을 것이다.

#### SOLID 원칙

* *S* ingle Responsibility Principle(단일 책임 원칙)
* *O* pen/Closed Principle(개방/폐쇄 원칙)
* *L* iskov Substitution Principle(리스코프 치환 원칙)
* *I* nterface Segregation Principle(인터페이스 분리 원칙)
* *D* ependency Inversion Principle(의존성 역전 원칙)

#### 단일 책임 원칙

다소 과장해서 말하면 모든 클래스(자바스크립트는 함수)는 반드시 한 가지 변경 사유가 있어야 한다.

정말 무리한 요건이다. 그럼 함수를 모조리 코드 한 줄만으로 작성하라는 말인가?

예제의 rj3.svg.line 함수는 어떤 형태의 데이터 소스라도 입력받하 SVG 라인 경로를 생성할 수 있다. 여기서 만약 데이터가 바뀌면? 이 함수는 단서가 될 만한 정보는 사실상 외부에서 다 받고 점 데이터에서 x, y 좌푯값을 추출하는 방법까지 넘겨 받는다. 정작 rj3.svg.line은 '아는'게 없다. 그저 점 데이터를 배열로 받아 SVG 경로를 그려주는 함수(내부 line)를 반환할 뿐이다.

rjs3.svg.line을 변경할 일이 과연 있을까? 이 함수의 유일한 관심사는 배열에서 SVG 경로를 만드는 일이다. 이 관심사를 어떠헥 이행할지는 철저하게 외부에서 제공한 함수에 달려 있으니 변경 할 이유가 전혀 없다.

#### 개방.폐쇄 원칙

"모든 소프트웨어 개체는 확장 가능성은 열어 두되 수정 가능성은 닫아야 한다"는 원칙이다.

즉, 어떤 경우라도 실행 코드를 변경하지 말고, 어떻게든 (상속 등의 방법으로) 재사용하고 확장하라는 뜻이다.

로버트 마틴조차도 이런 말을 남겼다. "일반적으로 완벽한 닫힘은 있을 수 없으니 모종의 전략이 필요합니다. 다시 말해서 설계장는 불가피한 변경 유형을 미리 선택할 수밖에 없습니다. 오랜 경험에서 비롯된 통찰력이 필요한 부분입니다."

d3.svg.line 함수를 설계할 때 마이크 보스톡은 데이터에서 좌푯값을 뽑아내는 방법과 점을 연결하는(보간하는) 방법에 변경 사항이 있으리라 내다보고 이러한 특성을 추상화하여 함수 밖으로 빼내는 기지를 발휘했다.

그가 변경되지 않을 거라고(적어도 이전 버전과 호환되지 않는 식으로 바뀌지 않을 거라) 본 건 SVG 경로의 규격이다. 반드시 "M"으로 시작해서 그 뒤에 점 데이터가 이어지는 문자열 형태로 과감히 경로 문자열을 하드 코딩한 것이다.

SVG 명세서가 하루아침에 바뀔 일은 없을 테니 d3.svg.line 역시 손댈 일은 거의 없을 것이다.

#### 리스코프 치환 원칙

리스코프 치환 원칙을 자바스크립트에서 흔한 표현으로 바꾸면 다음과 같다.

> 어떤 타입에서 파생된 타입의 객체가 있다면 이 타입을 사용하는 코드는 변경하지 말아야 한다.

다시 말해, 한 객체를 다른 객체에서 파생하더라도 그 기본 로직이 변경되어서는 안 된다는 뜻이다. 여러분이 작성 중인 함수가 기반 클래스로 하는 일과 서브 클래스로 하는 일이 다르다면 이 원칙을 어긴 셈이다.

서로 파생 관계가 없는 타입 간에는 적용되지 않는다. 예컨데 자바스크립트에서는 어떤 함수의 인자가 숫가일 때, 문자열일 때, 아예 인자가 업슨 undefined 타입일 때를 각각 분기 처리하는 것이 대게 좋은 습관이다.

덕 타이핑 역시 파생과는 조금 다르지만, 이 원칙과 잘 들어 맞는다.

#### 인터페이스 분리 원칙

이 원칙은 C++, 자바 같은 인터페이스 기반 언어 환경에서 비롯되었다. 이들 언어에서 인터페이스란 클래스에서 어떤 기능을 '구현'하지 않고(명칭, 파라미터, 반환 타입을) '서술'만 한 코드 조각이다.

기능이 많은 인터페이스는 더 작게 응축시킨 조각으로 나누어야 한다는 발상이다. 인터페이스 사용부는 '뚱뚱한' 전체가 아니라 아주 작은 인터페이스 하나만 바라보면 된다.

물론 모듈 간 연결 폭을 최소화하는 방향으로 가야 한다.

자바스크립트에서 이 원칙을 어떻게 실현하는지는 16장에 나와 있다.

인터페이스 분리 원칙의 정신을 실현하려면 함수가 기대하는 인자가 무엇인지 명확히 하고 그 기대치를 최소화해야 한다. 이럴 때도 덕 타이핑이 도움된다. 특정 타입의 인자를 바라기보다는 이 타입에서 실제로 필요한 프로퍼티가 더러 있을 거라 기대하는 것이다.

#### 의존성 역전 원칙

이 원칙도 인터페이스와 관련 있다. 로버트 마틴은 "상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 되며 이 둘은 추상화에 의존해야 한다".라고 말했다.

인터페이스 기반 언어에서는 대개 의존성 주입이라는 연관된 개념으로 표현한다. 클래스 A가 클래스 B의 서비스가 필요할 때 A는 B를 생성하지 않는다. 대신 A 생성자에 건넨 파라미터 하나가 B를 서술하는 인터페이스 역할을 한다. 이제 A는 B에 의존하지 않고 자신의 인터페이스만 바라본다. A가 생성되면 구체화한 B를 넘겨 받는다. B 역시 인터페이스에 의존한다.

리스코프 치환 원칙 덕분에 인터페이스를 만족하는, B의 파생형 버전을 제공할 수 있는 이점이 있다. 또한, 인터페이스는 (개방/폐쇄 원칙에도 불구하고) B를 고쳐야 할 경우 하위 버전 호환성을 유지하려면 어떤 로직을 계속 갖고 있어야 하는지 일목요연하게 서술한다.

#### DRY 원칙

"Don't Repeat Yourself"라는 말 역시 좋은 소프트웨어 개발 습관의 근원이다. "모든 지식 조각은 딱 한 번만 나와야 한다"라는 말이다.

먼저, 가장 중요한 SOLID의 원칙 중 일부가 DRY 원칙의 필연적 산물이다.

단일 책임 원칙이 그렇다. 이 원칙을 어긴 코든느 결과적으로 다시 쓸 수 없다. X와 Y를 함께 하는 모듈이 있다. X를 하는 코드가 필요할 때 Y 로직을 들어내지 않는 한 모듈을 재사요할 수 없으므로 또 다시 X를 코딩할 수밖에 없다. DRY 원칙과 맞지 않다.

X와 Y를 하는 함수 2개를 모듈에 주입해서 하나의 책임으로 묶어두면 문제를 해결할 수 있다. DRY한 코드로 만드는 과정에 의존성 주입과 단일 책임 문제가 개입된다.

DRY함은 여타 언어와 비교했을 때 자바스크립트에서 특별히 중요하다. 자바스크립트는 잘못 코딩한 특정 클래스를 컴파일러가 미리 알려주지 않으니 자칫 그대로 운영 환경에 노출될 가능성이 크다. 참사를 예방하려면 될 수 있는 대로 빨리 실수를 인지하는게 상책이다.
