# 3장 객체를 바르게 만들기

* [3-1 원시형](#3-1-원시형)
* [3-2 객체 리터럴](#3-2-객체-리터럴)
* [3-3 모듈 패턴](#3-3-모듈-패턴)

이 장의 주제

* 원시형 객체 리터럴, 모듈 형태로 데이터를 생성한다.
* 데이터를 new 키워드로 생성한다.
* 객체 생성 메서드로 객체를 올바르게 만든다.
* 프로토타입, 고전적, 함수형 패턴을 동원하여 상속을 구사한다.
* 멍키 패치를 바르게 사용한다.

## 3-1 원시형

ECMAScript5 명세 기준으로 자바스크립트의 원시형은 String, Number, Boolean, null, undefined 5개가 전부다.(ECMAScript 6부터 심볼이 추가됐다. 객체는 원시형에 속하지 않는다)

원시형 변수는 값은 있되 프로퍼티가 없어서 다음 코드는 에러가 날 것 같지만, 문제 없이 실행된다.

```js
var str = "abcde";
console.log(str.length); // 실행 결과: 5
```

자바스크립트 엔진이 str에서 String 객체를 만들고 이 객체의 length 프로퍼티 값을 참조한다. 물론 이렇게 만든 String 객체는 곧바로 가비지 컬렉션 대상이 된다.

문자열, 불, 숫자 타입 모두 그들만의 객체 래퍼(wrapper), 즉 String(값), Boolean(값), Number(값)를 지닌다.

동물 체중을 킬로그램(kg) 단위로 표시한 변수가 있고 입력한 값을 다음과 같이 처리한다고 하자.

```js
if (inputMass < 0) {
  // 체중이 음수일 리 없다는 에러 메시지를 낸다.
} else if (inputMass > 150000) {
  // 에러: 흰수염고래도 이렇게 무겁진 않다고요!
}
```

그리고 이 코드를 다른 곳에서 똑같이 복사해 쓴다. DRY와는 거리가 먼 이런 코드를 개선할 수 없을까? 범위 체크 기능을 심을 객체로 변환하면 된다. 원시형을 무조건 객체로 바꾸라는 건 아니고 상황에 맞게 고려해볼 수 있다.

원시형을 자꾸 반복하는 건 좋지 않다. 변수에 값을 넣고 다른 곳에서 참조하느니 아무래도 그냥 값을 한번 더 입력해넣는 게 알기 쉽고 편하다.

드문 예외가 있긴 하지만, 한 번 이상 참조할 상수는 변수에 담아두고 변수를 대신 참조하라. 상수를 의존성으로 주입하는 방법도 있다. 이러헥 해야 코드를 DRY하게 유지하면서 특정 갑을 사용하는 코드를 찾기가 쉽다.

#### 원시형의 SOLID/DRY 요약표

| 원칙 | 결과 |
|-|-|
|단일 책임|O|
|개방/폐쇄|확장에 개방적 X, 변경에 폐쇄적 O, 원시형은 불변값(immutable)|
|리스코프 치환|해당 없음|
|인터페이스 분리|인터페이스 구현 불가능|
|의존성 역전|의존성 같은 건 없음|
|DRY|유혹을 느끼는 부분|

## 3-2 객체 리터럴

객체 리터럴(object literal)은 다음과 같이 선언한 객체를 말한다.

```js
{name: 'Koko', genus: 'gorilla', genius: 'sign language'}
```

객체 리터럴은 두 가지 생성 방법이 있다.

먼저 단순 객체 리터럴(bare object literal)이다.

```js
{name: 'Koko', genus: 'gorilla', genius: 'sign language'};
```

이번에는 객체 리터럴이 함수 반환값인 경우다.

```js
var amazeTheWorld = function() {
  // ...
  return {name: 'Koko', genus: 'gorilla', genius: 'sign language'};
}

var koko = amazeTheWorld();
```

둘 중 하나가 다른 하나보다 더 DRY하다.

같은 프로퍼티를 지닌 객체 리터럴을 여럿 생성할 때 계속 반복되는 프로퍼티명을 입력하다 보면 실수하기 마련이다. 사실 TDD 방식으로 어떤 함수가 원하는 프로퍼티를 지닌 객체를 반환하는지는 충분히 확인할 수 있다. 하지만 단순 객체 리터럴만으로는 직접 테스트할 방법이 마땅치 않다.

객체 리터럴은 함수 프로퍼티를 가질 수 있는데, 단순 객체 리터럴은 마찬가지로 테스트할 도리가 없다.

애스팩트를 적용하려면 포인트컷(예: 변수명)이 있어야 하는데 객체 리터럴은 이름 자체가 없기 때문에 문제가 된다. 하지만 팩토리 함수로 생성하면 반환된 리터럴을 갖고 놀 after 애스팩트에 함수를 래핑할 수 있다.

단순 객체 리터럴에서는 의존성 주입은 아예 시도조차 할 수 없지만, 리터럴을 생성/반환하는 함수는 의존성을 주입하는 과정에 아주 잘 어울린다.

단순 객체 리터러은 생성 시 검증 할 수 없다는 것도 문제다. 그러므로 객체 리터럴은 싱글톤 또는 확실히 테스트를 마친 코드에서 생성된 객체 리터럴이 아니라면 중요한 애플리케이션 부분에 쓰지 않는 편이 좋다.

객체 리터럴은 한 곳에서 다른 곳으로 데이터 뭉치를 옮길 때 쓰기 편하다. 함수 인자가 워낙 많아 그 순서를 정확히 맞추기 쉽지 않을 때 객체 리터럴을 사용하면 유용하다. 리터럴에 프로퍼티가 하나도 없다는 건 기본값을 사용하라는 신호로 받아들일 수 있다.

쓰기 편하지만 한 가지 명심하자! 함수가 어떤 프로퍼티 조합도 대비할 수 있으려면 그만큼 테스트를 많이 해야 하는 부담이 생긴다. 생성 방식을 잘 다스릴 수 있고 테스트를 확실히 마친, 말하자면 isValid 같은 메서드로 검증 가능한 객체를 대용하는 방안을 고민하라.

#### 객체 리터럴의 SOLID/DRY 요약표

| 원칙 | 결과 |
|-|-|
|단일 책임|단순 객체 리터럴은 아주 작은 편이어서 이 평가 항목에 문제가 될 만한 부분은 없다. 모듈 API를 구성하는 덩치 큰 객체 리터럴은 자신의 모듈이 담당한 모든 책임을 진다.|
|개방/폐쇄|객체 리터럴 특성상 제멋대로 확장될지 모르니 조심하라!|
|리스코프 치환|해당 없음|
|인터페이스 분리|모듈 패턴 및 멍키 패칭을 참고|
|의존성 역전|단순 객체 리터럴은 내부에 의존성을 주입할 생성자가 없으니 불가능|
|DRY|싱글톤이 아닌 단순 객체 리터럴은 WET한 코드가 되기 일쑤다. 반드시 유념하라!|

## 3-3 모듈 패턴

모듈 패턴은 자바스크립트에서 가장 명망 높은 패턴 중 하나다. 데이터 감춤이 주목적인 함수가 모듈 API를 이루는 객체를 반환하게 한다. 임의로 함수를 호출하여 생성하는 모듈과 선언과 동시에 실행하는 함수에 기반을 둔 모듈이 있다.

### 3-3-1 임의 모듈 생성

다음 예제는 원하는 시점에 언제라도 생성할 수 있는 모듈로, 모듈 함수를 호출하여 API를 얻는다.

```js
// 해당 애플리케이션에서만 사용할 수 있는 모든 객체(모듈)를 담아 넣은
// 전역 객체를 선언하여 이름공간처럼 활용한다.
var MyApp = MyApp || {};

// 애플리케이션 이름공간에 속한 모듈
// 이 함수는 animalMaker라는 다른 함수에 의존하며 animalMaker는 주입 가능하다.
MyApp.wildlifePreserveSimulator = function(animalMaker) {
  // 프라이빗 변수
  var animals = [];

  // API를 반환
  return {
    addAnimal: function(species, sex) {
      animals.push(animalMaker.make(species, sex));
    },
    getAnimalCount: function() {
      return animals.length;
    }
  };
};
```

모듈은 다음과 같이 사용한다.

```js
var preserve = Myapp.wildlifePreserveSimulator(realAnimalMaker);
preserve.addAnimal(gorilla, female);
```

이 모듈은 객체 리터럴을 반환하나 animalMaker 같은 의존성을 외부 함수에 주입하여 리터럴에서 참조하게 만들 수 있다.

다른 모듈에 주입할 수 있어 확장성이 좋다. 옛 버전 모듈을 새 버전 모듈에 주입하여 원하는 대로 래핑, 표출, 확장 등을 꾀할 수 있다. 개방/폐쇄 원칙이 최우선 관심사라면 모듈만한 것도 또 없다.

MyApp.wildlifePreserveSimulator에 after 어드바이스르 ㄹ넣어 반환된 객체에 애스팩트를 적용하는 방법도 있다. 이 어드바이스는 변환된 리터럴을 쥐고 있다가 필요에 따라 이 리터럴을 다른 애스팩트로 수정하게 될 것이다.

### 3-3-2 즉시 실행 모듈 생성

API를 반환하는 건 임의 모듈과 같지만, 외부 함수를 선언하자마자 실행하는 방법이다. 반환된 API는 이름공간을 가진 전역 변수에 할당된 후 해당 모듈의 싱글톤 인스턴스가 된다.

```js
var MyApp = MyApp || {};

MyApp.WildlifePreserveSimulator = (function() {
  // 프라이빗 변수
  var animals = [];

  // API를 반환
  return {
    addAnimal: function(animalMaker, species, sex) {
      animals.push(animalMaker.make(species, sex));
    },
    getAnimalCount: function() {
      return animals.length;
    }
  };
}()); // 즉시 실행한다
```

싱글톤은 이렇게 사용한다.

```js
MyApp.WildPreserveSimulator.addAnimal(realAnimalMaker, gorilla, female);
```

외부 함수는 애플리케이션 기동 코드의 실행과 상관없이 코드가 장성된 지점에서 즉시 실행된다. 따라서 함수 (즉시) 실행 시 의존성을 가져오지 못하면 외부 함수에 주입할 수 없다. 싱글톤이 꼭 필요하다면 임의 모듈 패턴으로 모듈을 코딩하고 해당 모듈을 요청할 때마다 의존성 주입 프레임워크에서 같은 인스턴스를 제공하는 편이 의존성 주입 측면에서 더 낫다.

### 3-3-3 모듈 생성의 원칙

임의든 즉시든 모듈을 생성할 때는 다음 사항을 유념하기 바란다.

첫째, 단일 책임 원칙을 잊지 말고 한 모듈에 한 가지 일만 시키자. 그래야 결속력이 강하고 다루기 쉬운, 아담한 API를 작성하게 된다.

둘째, 모듈 자신이 쓸 객체가 필요하다면 의존성 주입 형태로 (직접 또는 팩토리 주입 형태로) 이 객체를 제공하는 방안을 고려하라.

셋째, 다른 객체 로직을 확장하는 모듈은 해당 로직의 의도가 바뀌지 않도록 분명히 밝혀라(리스코프 치환 원칙).

#### 모듈 패턴에 관한 SOLID/DRY 요약표

| 원칙 | 결과 |
|-|-|
|단일 책임|모듈은 태생 자체가 의존성 주입과 친화적이고 애스팩트 지향적이라 단일 책임 유지는 어렵지 않다.|
|개방/폐쇄|다른 모듈에 주입하는 형태로 얼마든지 확장할 수 있다. 통제해야 할 모듈은 수정하지 못하게 차단할 수 있다.|
|리스코프 치환|의존성의 의미를 뒤바꾸는 일만 없으면 별문제 없다.|
|인터페이스 분리|결합된 API 모듈 자체가 자바스크립트에서 분리된 인터페이스나 다름없다.|
|의존성 역전|임의 모듈은 의존성으로 주입하기 쉽다. 모듈이 어떤 형태든 다른 모듈에 주입할 수 있다.|
|DRY|제대로만 쓴다면 DRY한 코드를 유지하는데 아주 좋은 방법이다.|
